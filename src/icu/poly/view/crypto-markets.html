<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>poly-market 加密市场</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root { --bg:#05070b; --card:#0f141c; --line:#1b2330; --muted:#94a3b8; --text:#f1f5f9; --accent:#38bdf8; }
        html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
        .wrap{max-width:none;width:100%;margin:24px 0;padding:0 24px;box-sizing:border-box;}
        h1{font-size:20px;margin:0 0 12px;}
        .bar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:16px;align-items:center;}
        .bar-event-group{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
        button{background:var(--accent);border:none;color:#021018;padding:9px 16px;border-radius:999px;font-weight:600;cursor:pointer;}
        button:disabled{opacity:.5;cursor:not-allowed;}
        .status{color:var(--muted);font-size:13px;}
        select{background:var(--card);color:var(--text);border:1px solid var(--line);border-radius:8px;padding:8px 12px;font-weight:500;}
        table{width:100%;border-collapse:collapse;background:var(--card);border-radius:14px;overflow:hidden;border:1px solid var(--line);table-layout:auto;}
        thead{background:rgba(255,255,255,.02);position:sticky;top:0;}
        th,td{text-align:center;padding:6px 8px;border-bottom:1px solid var(--line);vertical-align:middle;}
        th{font-size:13px;color:var(--muted);white-space:nowrap;text-align:center;}
        tbody tr:hover{background:rgba(56,189,248,.08);}
        .muted{color:var(--muted);}
        .chip{display:inline-block;border:1px solid var(--line);padding:2px 10px;border-radius:999px;font-size:12px;color:var(--muted);margin-left:8px;}
        .home-link{display:inline-block;margin-left:12px;padding:6px 14px;background:var(--accent);color:#021018;border-radius:999px;font-weight:600;text-decoration:none;font-size:13px;cursor:pointer;}
        .home-link:hover{opacity:0.9;}
        .scroll{overflow:auto;border-radius:14px;}
        code{padding:2px 4px;background:#1e293b;border-radius:4px;}
        .cell-value{display:inline-block;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
        th.col-question,td.col-question{min-width:220px;max-width:420px;}
        th.col-time,td.col-time{white-space:nowrap;}
        .detail-panel{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:20px;z-index:10;}
        .detail-panel.active{display:flex;}
        .detail-card{background:var(--card);border:1px solid var(--line);border-radius:12px;max-width:720px;width:100%;max-height:90vh;display:flex;flex-direction:column;}
        .detail-card header{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line);}
        .detail-card pre{margin:0;padding:16px;overflow:auto;white-space:pre-wrap;word-break:break-word;font-size:12px;background:#020812;border-bottom-left-radius:12px;border-bottom-right-radius:12px;}
        .detail-card button{margin:0;}
        .detail-trigger{background:none;border:1px solid var(--line);color:var(--text);padding:4px 10px;border-radius:8px;font-size:12px;}
        .detail-trigger:hover{border-color:var(--accent);color:var(--accent);}
        .order-card{max-width:480px;}
        .order-meta{padding:16px;border-bottom:1px solid var(--line);font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px;}
        .order-form{display:flex;flex-direction:column;gap:12px;padding:16px;}
        .order-form label{display:flex;flex-direction:column;font-size:13px;color:var(--muted);gap:6px;}
        .order-form input{padding:8px 10px;border-radius:8px;border:1px solid var(--line);background:var(--bg);color:var(--text);}
        .order-actions{display:flex;gap:8px;justify-content:flex-end;padding:0 16px 16px;}
        .order-status{padding:0 16px 16px;font-size:13px;color:var(--muted);}
        .order-token-group{display:flex;gap:12px;align-items:center;}
        .order-token-option{display:flex;align-items:center;gap:6px;font-size:13px;color:var(--muted);}
        .order-token-option input{accent-color:var(--accent);}
        .toast-container{position:fixed;right:24px;bottom:24px;display:flex;flex-direction:column;gap:10px;z-index:40;}
        .toast{background:rgba(15,20,28,0.95);border:1px solid var(--line);border-radius:10px;padding:12px 16px;min-width:240px;box-shadow:0 10px 30px rgba(0,0,0,0.4);animation:fadeIn .2s ease;}
        .toast strong{display:block;font-size:14px;margin-bottom:6px;}
        .toast button{margin-top:8px;padding:4px 8px;font-size:12px;}
        @keyframes fadeIn{from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}
        .chart-section{margin-top:24px;padding:18px;border:1px solid var(--line);border-radius:16px;background:var(--card);display:flex;flex-direction:column;gap:16px;}
        .chart-head{display:flex;flex-wrap:wrap;justify-content:space-between;gap:16px;}
        .chart-title{margin:0;font-size:18px;}
        .chart-status{margin:4px 0 0;font-size:13px;color:var(--muted);}
        .chart-range,.chart-window-info{margin:0;font-size:12px;color:var(--muted);}
        .chart-controls{display:flex;align-items:flex-end;gap:8px;}
        .chart-controls label{display:flex;flex-direction:column;font-size:13px;color:var(--muted);gap:4px;}
        .chart-controls select{min-width:120px;}
        .chart-visual{border:1px solid var(--line);border-radius:16px;padding:16px;background:rgba(255,255,255,0.01);display:flex;flex-direction:column;gap:16px;}
        .chart-main{display:flex;flex-direction:column;gap:12px;}
        .chart-main-canvas{position:relative;}
        .chart-hover-label{position:absolute;min-width:160px;max-width:220px;padding:10px 12px;border-radius:10px;background:rgba(5,7,11,0.92);border:1px solid rgba(56,189,248,0.4);box-shadow:0 8px 30px rgba(0,0,0,0.45);font-size:12px;color:var(--text);pointer-events:none;opacity:0;transform:translate(-50%,-120%);transition:opacity .12s ease,transform .12s ease;display:none;z-index:2;}
        .chart-hover-label.active{display:block;opacity:1;transform:translate(-50%,-140%);}
        .chart-hover-label strong{display:block;font-size:13px;margin-bottom:2px;color:var(--accent);}
        .chart-hover-label span{display:block;color:var(--muted);}
        #yesTokenChart{width:100%;height:1120px;border-radius:12px;border:1px solid var(--line);background:linear-gradient(180deg,#07101d,#02060c);display:block;}
        #chartEmpty{position:absolute;top:0;left:0;right:0;height:1000px;display:flex;align-items:center;justify-content:center;font-size:13px;color:var(--muted);pointer-events:none;}
        .chart-legend{display:flex;flex-wrap:wrap;gap:12px;font-size:12px;color:var(--muted);}
        .chart-legend-item{display:flex;align-items:center;gap:6px;}
        .chart-legend-dot{width:10px;height:10px;border-radius:50%;}
        .chart-token-panel{border:1px dashed var(--line);border-radius:14px;padding:12px;background:#060b14;display:flex;flex-direction:column;gap:10px;}
        .chart-token-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;font-size:13px;color:var(--muted);}
        .chart-token-actions{display:flex;gap:8px;}
        .chart-token-actions button{padding:6px 14px;font-size:12px;}
        .chart-token-list{display:flex;flex-wrap:wrap;gap:8px;}
        .chart-token-item{flex:1 1 220px;min-width:200px;border:1px solid var(--line);border-radius:12px;padding:8px 10px;background:#04070d;display:flex;align-items:center;gap:10px;}
        .chart-token-item label{flex:1;display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted);}
        .chart-token-item strong{font-size:14px;color:var(--text);}
        .chart-token-item input[type="checkbox"]{width:16px;height:16px;accent-color:var(--accent);}
        .chart-token-empty{font-size:13px;color:var(--muted);}
        .timeline-hint{font-size:12px;color:var(--muted);margin:4px 0 0;text-align:right;}
        @media (max-width:600px){
            .detail-card{max-width:none;height:90vh;}
        }
        @media (max-width:900px){
            table,thead,tbody,tr,td,th{display:block;}
            thead{display:none;}
            tr{border-bottom:1px solid var(--line);}
            td{display:flex;justify-content:space-between;gap:12px;align-items:center;}
            td::before{content:attr(data-th);font-weight:600;color:var(--muted);}
            .cell-value{flex:1;text-align:right;display:block;}
            th.col-question,td.col-question{width:auto;min-width:0;}
            th.col-time,td.col-time{width:auto;min-width:0;}
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Polymarket 加密市场列表 <span class="chip">末日市场</span> <a href="/dashboard" class="home-link">返回数据面板</a></h1>
    <div class="bar">
        <button id="outcomeToggle">筛选：YES/NO</button>
        <select id="tagSelect" aria-label="标签筛选"></select>
        <div class="bar-event-group">
            <select id="eventSelect" aria-label="事件筛选"></select>
            <button id="reload">刷新数据</button>
        </div>
        <span id="status" class="status"></span>
    </div>
    <div class="scroll">
        <table>
            <thead>
            <tr id="cols"></tr>
            </thead>
            <tbody id="rows"></tbody>
        </table>
    </div>
    <section class="chart-section">
        <div class="chart-head">
            <div>
                <h2 class="chart-title">YES Token 价格曲线</h2>
                <p id="chartStatus" class="chart-status">等待市场列表加载…</p>
                <p id="chartRange" class="chart-range"></p>
                <p id="chartWindowInfo" class="chart-window-info">窗口：—</p>
            </div>
            <div class="chart-controls">
                <label>
                    时间粒度
                    <select id="chartInterval"></select>
                </label>
            </div>
        </div>
        <div class="chart-token-panel">
            <div class="chart-token-head">
                <span>曲线列表（自动来自当前市场）</span>
                <div class="chart-token-actions">
                    <button type="button" id="chartSelectAll">全选</button>
                    <button type="button" id="chartClearAll">全不选</button>
                </div>
            </div>
            <div id="chartTokenList" class="chart-token-list"></div>
        </div>
        <div class="chart-visual">
            <div class="chart-main">
                <div class="chart-main-canvas">
                    <canvas id="yesTokenChart" width="2000" height="1120" role="img" aria-label="市场 YES token 价格曲线"></canvas>
                    <div id="chartHoverLabel" class="chart-hover-label" aria-hidden="true">
                        <strong id="chartHoverLabelTitle"></strong>
                        <span id="chartHoverLabelTime"></span>
                        <span id="chartHoverLabelPrice"></span>
                    </div>
                    <div id="chartEmpty">暂无可绘制的 YES token</div>
                </div>
                <span class="timeline-hint">拖动底部选择框即可缩放/移动时间区间</span>
            </div>
        </div>
        <div id="chartLegend" class="chart-legend"></div>
    </section>
</div>

<div id="detailPanel" class="detail-panel">
    <div class="detail-card">
        <header>
            <span id="detailTitle"></span>
            <button id="detailClose">关闭</button>
        </header>
        <pre id="detailJson"></pre>
    </div>
</div>

<div id="orderPanel" class="detail-panel">
    <div class="detail-card order-card">
        <header>
            <span>下单</span>
            <button id="orderClose">关闭</button>
        </header>
        <div class="order-meta">
            <strong id="orderQuestion">—</strong>
            <div class="order-token-group" id="orderTokenGroup"></div>
            <div>事件：<span id="orderEventSlug" class="muted">—</span></div>
            <div>当前最优卖价：<span id="orderBestAsk" class="muted">—</span></div>
        </div>
        <form id="orderForm" class="order-form">
            <label>
                买单价格（%）
                <input type="number" id="orderBuyPrice" step="0.1" min="0.1" max="100" required />
            </label>
            <label>
                买单数量
                <input type="number" id="orderSize" step="1" min="1" required />
            </label>
            <label>
                止盈卖价（%，可选）
                <input type="number" id="orderTakeProfit" step="0.1" min="0" max="100" />
            </label>
            <div class="order-actions">
                <button type="submit" id="orderSubmit">提交</button>
            </div>
        </form>
        <p id="orderStatus" class="order-status"></p>
    </div>
</div>

<div id="orderToastContainer" class="toast-container"></div>

<script>
    const API = "/api/crypto-markets";
    const ORDERBOOK_API = "/api/orderbook";
    const ORDERBOOK_BATCH_SIZE = 8;
    const PRICE_HISTORY_API = "/api/price-history";
    const POLY_EVENT_BASE_URL = "https://polymarket.com/event/";
    const CHART_INTERVALS = [
        {value: "1h", label: "1 小时"},
        {value: "6h", label: "6 小时"},
        {value: "1d", label: "1 天"},
        {value: "1w", label: "1 周"},
        {value: "max", label: "Max"},
    ];
    const CHART_ZOOM_MIN = 0.05;
    const CHART_ZOOM_MAX = 1;
    const TIMELINE_HEIGHT = 100;
    const TIMELINE_PADDING = 24;
    const MAIN_CHART_HEIGHT = 1000;
    const TIMELINE_GAP = 20;
    const TOTAL_CANVAS_HEIGHT = MAIN_CHART_HEIGHT + TIMELINE_GAP + TIMELINE_HEIGHT;
    const CHART_COLORS = ["#22d3ee", "#fb7185", "#a78bfa", "#34d399", "#f472b6", "#f97316", "#38bdf8", "#facc15"];
    const CHART_HOVER_MAX_DISTANCE = 32;
    const BTC_HISTORY_API = "/api/btc-history";
    const BTC_SERIES_ID = "btc-usdt";
    const BTC_SERIES_LABEL = "BTC/USDT（右轴）";
    const BTC_SERIES_COLOR = "#fbbf24";
    const BTC_AXIS_LABEL = "BTC 价格 (USDT)";
    const BTC_INTERVAL_MINUTES = 15;
    const BTC_INTERVAL_MS = BTC_INTERVAL_MINUTES * 60 * 1000;
    const fields = [
        { key: "question", label: "问题", className: "col-question" },
        { key: "outcomes", label: "结果" },
        { key: "endDate", label: "结束时间", className: "col-time" },
        { key: "yesBestAsk", label: "YES最优卖价" },
        { key: "yesBestBid", label: "YES最优买价" },
        { key: "noBestAsk", label: "NO最优卖价" },
        { key: "noBestBid", label: "NO最优买价" },
        { key: "volume24hr", label: "24h 交易量", compact: true },
        { key: "liquidityNum", label: "流动性", compact: true },
    ];
    const compactNumberKeys = new Set(fields.filter(f => f.compact).map(f => f.key));
    const priceMultiplierKeys = new Set(["lastTradePrice"]);
    const PRICE_MULTIPLIER = 100;
    const PRICE_DISPLAY_MULTIPLIER = 100;
    const PRICE_DISPLAY_DECIMALS = 1;
    const PRICE_FIELD_KEYS = new Set(["yesBestAsk", "yesBestBid", "noBestAsk", "noBestBid"]);
    const TAG_OPTIONS = [
        { id: 21, label: "Crypto" },
        { id: 235, label: "Bitcoin" },
        { id: 39, label: "Ethereum" },
    ];
    const DEFAULT_TAG_ID = 235;
    let outcomeMode = "yesno";
    let currentData = [];
    let currentTagId = DEFAULT_TAG_ID;
    let currentEventTicker = null;
    let lastRenderedMarkets = [];
    let chartInterval = "1d";
    let lastChartDatasets = [];
    let chartRequestId = 0;
    let chartAbortController = null;
    let chartTokens = [];
    let chartTimeBounds = null;
    let chartViewSpan = 1;
    let chartViewOffsetRatio = 0;
    let chartCurrentWindow = null;
    let timelineDragState = null;
    let chartRenderState = null;
    let chartHoverData = null;
    const selectedChartTokenIds = new Set();
    const chartHistoryCache = new Map();
    const btcHistoryCache = new Map();
    const tokenBestAskCache = new Map();
    const tokenBestBidCache = new Map();
    const tokenOrderBookRequests = new Map();
    const tokenOrderBookQueue = [];
    const tokenOrderBookQueued = new Set();
    let pendingOrderBookRefresh = false;
    let orderBookRefreshTimer = null;
    let orderBookVersion = 0;
    let currentBtcInterval = null;
    let currentBtcBounds = null;
    let currentBtcCacheKey = null;
    let currentOrderContext = null;
    const detailKeys = [
        "id",
        "question",
        "conditionId",
        "slug",
        "endDate",
        "startDate",
        "outcomes",
        "outcomePrices",
        "createdAt",
        "questionID",
        "volumeNum",
        "liquidityNum",
        "endDateIso",
        "startDateIso",
        "volume24hr",
        "clobTokenIds",
        "events",
        "lastTradePrice",
        "bestBid",
        "bestAsk",
        "eventStartTime",
    ];
    const eventDetailKeys = ["id", "ticker", "slug", "title", "startDate", "endDate"];

    const $ = (id) => document.getElementById(id);
    const cols = $("cols");
    const statusEl = $("status");
    const reloadBtn = $("reload");
    const outcomeToggleBtn = $("outcomeToggle");
    const tagSelect = $("tagSelect");
    const eventSelect = $("eventSelect");
    const chartCanvas = $("yesTokenChart");
    const chartEmpty = $("chartEmpty");
    const chartLegend = $("chartLegend");
    const chartStatusEl = $("chartStatus");
    const chartRangeEl = $("chartRange");
    const chartIntervalSelect = $("chartInterval");
    const chartWindowInfo = $("chartWindowInfo");
    const chartTokenList = $("chartTokenList");
    const chartSelectAllBtn = $("chartSelectAll");
    const chartClearAllBtn = $("chartClearAll");
    const chartHoverLabel = $("chartHoverLabel");
    const chartHoverLabelTitle = $("chartHoverLabelTitle");
    const chartHoverLabelTime = $("chartHoverLabelTime");
    const chartHoverLabelPrice = $("chartHoverLabelPrice");
    const orderPanel = $("orderPanel");
    const orderCloseBtn = $("orderClose");
    const orderQuestionEl = $("orderQuestion");
    const orderTokenGroup = $("orderTokenGroup");
    const orderEventSlugEl = $("orderEventSlug");
    const orderBestAskEl = $("orderBestAsk");
    const orderToastContainer = $("orderToastContainer");
    const orderForm = $("orderForm");
    const orderBuyPriceInput = $("orderBuyPrice");
    const orderSizeInput = $("orderSize");
    const orderTakeProfitInput = $("orderTakeProfit");
    const orderStatusEl = $("orderStatus");
    const orderSubmitBtn = $("orderSubmit");
    fields.forEach(f => {
        const th = document.createElement("th");
        th.textContent = f.label;
        if (f.className) th.classList.add(f.className);
        cols.appendChild(th);
    });
    const detailHead = document.createElement("th");
    detailHead.textContent = "详细";
    cols.appendChild(detailHead);
    const goHead = document.createElement("th");
    goHead.textContent = "前往";
    cols.appendChild(goHead);
    const orderHead = document.createElement("th");
    orderHead.textContent = "下单";
    cols.appendChild(orderHead);

    const dateFieldRegex = /(date|time)$/i;
    const compactFormatter = new Intl.NumberFormat("en", { notation: "compact", maximumFractionDigits: 1 });
    const chartDateFormatter = new Intl.DateTimeFormat("zh-CN", {
        timeZone: "Asia/Shanghai",
        hour12: false,
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
    });
    const PRICE_GRID_STEPS = 20;
    const outcomeSetMap = {
        yesno: new Set(["yes", "no"]),
        updown: new Set(["up", "down"]),
    };

    function parseJsonArray(value) {
        if (Array.isArray(value)) return value;
        if (typeof value === "string") {
            try {
                const parsed = JSON.parse(value);
                if (Array.isArray(parsed)) return parsed;
            } catch (_) {
                // ignore malformed json
            }
        }
        return null;
    }

    function parseOutcomes(value) {
        const parsed = parseJsonArray(value);
        return Array.isArray(parsed) ? parsed : null;
    }

    function parseClobTokenIds(value) {
        const parsed = parseJsonArray(value);
        return Array.isArray(parsed) ? parsed : null;
    }

    function parseOutcomePrices(value) {
        const parsed = parseJsonArray(value);
        return Array.isArray(parsed) ? parsed : null;
    }

    function getTokenIds(item) {
        const tokens = parseClobTokenIds(item?.clobTokenIds);
        if (!tokens || !tokens.length) return [];
        return tokens
            .map(token => (token === undefined || token === null ? null : String(token)))
            .filter(Boolean)
            .slice(0, 2);
    }

    function shorten(value) {
        if (!value) return "";
        const str = String(value);
        return str.length <= 16 ? str : `${str.slice(0, 6)}…${str.slice(-4)}`;
    }

    function buildFallbackLabel(context, tokenId, preferredLabel) {
        if (preferredLabel) return preferredLabel;
        const ticker = context?.ticker || null;
        if (ticker) return ticker;
        if (typeof context?.question === "string" && context.question.trim()) return context.question.trim();
        return shorten(tokenId);
    }

    function extractMarketTicker(item) {
        if (!item || typeof item.ticker !== "string") return null;
        const trimmed = item.ticker.trim();
        return trimmed.length ? trimmed : null;
    }

    function extractEventTicker(item) {
        if (!item || !Array.isArray(item.events) || !item.events.length) return null;
        const event = item.events[0];
        if (!event || typeof event.ticker !== "string") return null;
        const trimmed = event.ticker.trim();
        return trimmed.length ? trimmed : null;
    }

    function getMarketLabelSource(item) {
        const question = typeof item?.question === "string" ? item.question.trim() : "";
        if (question) return question;
        const marketTicker = extractMarketTicker(item);
        if (marketTicker) return marketTicker;
        return extractEventTicker(item);
    }

    function sliceBetweenBeAndOn(text) {
        if (typeof text !== "string") return null;
        const lower = text.toLowerCase();
        const beIndex = lower.indexOf(" be ");
        if (beIndex === -1) return null;
        const onIndex = lower.indexOf(" on ", beIndex + 4);
        if (onIndex === -1) return null;
        const start = beIndex + 4;
        const raw = text.slice(start, onIndex).replace(/\?+$/, "").trim();
        return raw.length ? raw : null;
    }

    function normalizeTickerLabel(value) {
        if (typeof value !== "string") return value;
        const trimmed = value.trim();
        if (!trimmed) return null;
        const between = sliceBetweenBeAndOn(trimmed);
        if (between) return between;
        const currencyMatch = trimmed.match(/\$[\d,]+(?:\.\d+)?/);
        if (currencyMatch) {
            const digits = currencyMatch[0].replace(/[$,]/g, "");
            return digits ? `$${digits}` : null;
        }
        const plainNumber = trimmed.replace(/,/g, "");
        if (/^\d+(?:\.\d+)?$/.test(plainNumber)) {
            return plainNumber;
        }
        return trimmed;
    }

    function getPrimaryEventSlug(item) {
        if (!item || !Array.isArray(item.events) || !item.events.length) return null;
        const slug = item.events[0]?.slug;
        if (typeof slug !== "string") return null;
        const trimmed = slug.trim();
        return trimmed.length ? trimmed : null;
    }

    function buildEventOptions(list) {
        const map = new Map();
        list.forEach(item => {
            const ticker = extractEventTicker(item);
            if (!ticker || map.has(ticker)) return;
            if (ticker.includes("15m") || ticker.includes("4h")) return;
            const event = Array.isArray(item.events) ? item.events[0] : null;
            map.set(ticker, {
                ticker,
                label: event?.title || event?.slug || ticker,
                endDate: event?.endDate || null,
            });
        });
        return [...map.values()].sort((a, b) => {
            const endA = normalizeSortDate(a.endDate);
            const endB = normalizeSortDate(b.endDate);
            if (endA !== endB) return endA - endB;
            return a.ticker.localeCompare(b.ticker);
        });
    }

    function updateEventFilterOptions(list) {
        if (!eventSelect) return;
        const options = buildEventOptions(list);
        eventSelect.innerHTML = "";
        if (!options.length) {
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "暂无事件";
            eventSelect.appendChild(opt);
            eventSelect.disabled = true;
            currentEventTicker = null;
            return;
        }
        options.forEach(info => {
            const opt = document.createElement("option");
            opt.value = info.ticker;
            const labelText = info.label === info.ticker ? info.ticker : `${info.ticker} · ${info.label}`;
            opt.textContent = labelText;
            eventSelect.appendChild(opt);
        });
        if (!currentEventTicker || !options.some(opt => opt.ticker === currentEventTicker)) {
            currentEventTicker = options[0].ticker;
        }
        eventSelect.value = currentEventTicker;
        eventSelect.disabled = options.length <= 1;
    }

    function getOutcomeCategory(value) {
        const parsed = parseOutcomes(value);
        if (!parsed || parsed.length !== 2) return null;
        const normalized = parsed.map(v => String(v).trim().toLowerCase());
        const unique = new Set(normalized);
        if (unique.size !== 2) return null;
        const entries = [...unique];
        if (entries.every(val => outcomeSetMap.yesno.has(val))) return "yesno";
        if (entries.every(val => outcomeSetMap.updown.has(val))) return "updown";
        return null;
    }

    function filterByEvent(list) {
        if (!currentEventTicker) return list;
        return list.filter(item => extractEventTicker(item) === currentEventTicker);
    }

    function filterByOutcomeMode(list) {
        return list.filter(item => getOutcomeCategory(item.outcomes) === outcomeMode);
    }

    function normalizeSortDate(value) {
        const time = new Date(value).getTime();
        return Number.isFinite(time) ? time : Number.POSITIVE_INFINITY;
    }

    function normalizeSortNumber(value) {
        if (typeof value === "number") {
            return Number.isFinite(value) ? value : Number.POSITIVE_INFINITY;
        }
        const num = Number(value);
        return Number.isFinite(num) ? num : Number.POSITIVE_INFINITY;
    }

    function sortMarkets(list) {
        return [...list].sort((a, b) => {
            const endA = normalizeSortDate(a.endDate);
            const endB = normalizeSortDate(b.endDate);
            if (endA !== endB) return endA - endB;
            const askA = normalizeSortNumber(a.bestAsk);
            const askB = normalizeSortNumber(b.bestAsk);
            return askA - askB;
        });
    }

    function formatDateToCST(value) {
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return new Intl.DateTimeFormat("zh-CN", {
            timeZone: "Asia/Shanghai",
            dateStyle: "short",
            timeStyle: "short",
        }).format(date);
    }

    function formatPrice(value, {fallback = "—", withUnit = true} = {}) {
        const numeric = typeof value === "number" ? value : Number(value);
        if (!Number.isFinite(numeric)) return fallback;
        const scaled = (numeric * PRICE_DISPLAY_MULTIPLIER).toFixed(PRICE_DISPLAY_DECIMALS);
        return withUnit ? `${scaled}%` : scaled;
    }

    function formatValue(value, field) {
        const key = typeof field === "string" ? field : field?.key;
        if (value === null || value === undefined || value === "") return "—";
        let displayValue = value;
        if (key && priceMultiplierKeys.has(key)) {
            const numeric = typeof displayValue === "number" ? displayValue : Number(displayValue);
            if (Number.isFinite(numeric)) {
                displayValue = Math.round(numeric * PRICE_MULTIPLIER);
            }
        }
        if (key && dateFieldRegex.test(key) && typeof displayValue === "string") {
            return formatDateToCST(displayValue);
        }
        if (key === "outcomes") {
            const parsed = parseOutcomes(displayValue);
            if (Array.isArray(parsed) && parsed.length === 2) {
                return outcomeMode === "yesno" ? "YES / NO" : "UP / DOWN";
            }
            if (Array.isArray(parsed)) return parsed.join(" / ");
            return displayValue;
        }
        if (key && PRICE_FIELD_KEYS.has(key)) {
            return formatPrice(displayValue);
        }
        if (Array.isArray(displayValue)) return displayValue.join(", ");
        if (typeof displayValue === "number") {
            if (key && compactNumberKeys.has(key)) {
                return compactFormatter.format(displayValue);
            }
            return Math.abs(displayValue) >= 1000 ? displayValue.toLocaleString() : displayValue;
        }
        if (typeof displayValue === "string") {
            if (key && compactNumberKeys.has(key)) {
                const num = Number(displayValue);
                if (!Number.isNaN(num)) {
                    return compactFormatter.format(num);
                }
            }
            try {
                const parsed = JSON.parse(displayValue);
                if (Array.isArray(parsed)) return parsed.join(", ");
            } catch (_) {
                // keep original string
            }
        }
        return displayValue;
    }

    function collectYesTokens(list) {
        const map = new Map();
        list.forEach(item => {
            const tokens = getTokenIds(item);
            const yesTokenId = tokens[0];
            if (!yesTokenId || map.has(yesTokenId)) return;
            const question = typeof item.question === "string" ? item.question.trim() : "";
            const labelSource = getMarketLabelSource(item);
            const fallbackPrice = extractOutcomePrice(item, 0);
            map.set(yesTokenId, {
                tokenId: yesTokenId,
                ticker: labelSource,
                question,
                bestAsk: resolveBestAskForToken(yesTokenId, fallbackPrice),
            });
        });
        const tokens = [...map.values()];
        return tokens.map(token => ({
            tokenId: token.tokenId,
            ticker: token.ticker,
            label: buildFallbackLabel(token, token.tokenId, normalizeTickerLabel(token.ticker ?? token.question)),
            question: token.question,
        }));
    }

    function enrichMarketStats(list) {
        return list.map(item => {
            const tokens = getTokenIds(item);
            const yesTokenId = tokens[0];
            const noTokenId = tokens[1];
            const yesAsk = resolveBestAskForToken(yesTokenId, extractOutcomePrice(item, 0));
            const noAsk = resolveBestAskForToken(noTokenId, extractOutcomePrice(item, 1));
            const yesBid = resolveBestBidForToken(yesTokenId);
            const noBid = resolveBestBidForToken(noTokenId);
            return {
                ...item,
                yesBestAsk: yesAsk,
                yesBestBid: yesBid,
                noBestAsk: noAsk,
                noBestBid: noBid,
            };
        });
    }

    function resolveBestAskForToken(tokenId, fallbackPrice = null) {
        if (!tokenId) return Number.isFinite(fallbackPrice) ? fallbackPrice : null;
        if (tokenBestAskCache.has(tokenId)) {
            const cached = tokenBestAskCache.get(tokenId);
            return Number.isFinite(cached) ? cached : null;
        }
        return Number.isFinite(fallbackPrice) ? fallbackPrice : null;
    }

    function resolveBestBidForToken(tokenId, fallbackPrice = null) {
        if (!tokenId) return Number.isFinite(fallbackPrice) ? fallbackPrice : null;
        if (tokenBestBidCache.has(tokenId)) {
            const cached = tokenBestBidCache.get(tokenId);
            return Number.isFinite(cached) ? cached : null;
        }
        return Number.isFinite(fallbackPrice) ? fallbackPrice : null;
    }

    function hasTokenBestQuotes(tokenId) {
        return tokenBestAskCache.has(tokenId) || tokenBestBidCache.has(tokenId);
    }

    function setTokenBestAsk(tokenId, price, version) {
        if (!tokenId || version !== orderBookVersion) return;
        const normalized = Number.isFinite(price) ? price : null;
        tokenBestAskCache.set(tokenId, normalized);
        if (orderTokenGroup) {
            const radios = Array.from(orderTokenGroup.querySelectorAll("input[name='orderTokenChoice']"));
            const radio = radios.find(input => input.value === tokenId);
            if (radio) {
                if (Number.isFinite(normalized)) {
                    radio.dataset.bestAsk = String(normalized);
                } else {
                    delete radio.dataset.bestAsk;
                }
                if (radio.checked) {
                    updateOrderBestAskDisplay({writeToInput: true});
                }
            }
        }
    }

    function setTokenBestBid(tokenId, price, version) {
        if (!tokenId || version !== orderBookVersion) return;
        const normalized = Number.isFinite(price) ? price : null;
        tokenBestBidCache.set(tokenId, normalized);
    }

    function extractBestAskFromOrderBook(payload) {
        const asks = Array.isArray(payload?.asks) ? payload.asks : [];
        if (!asks.length) return null;
        const last = asks[asks.length - 1];
        const price = Number(last?.price);
        return Number.isFinite(price) ? price : null;
    }

    function extractBestBidFromOrderBook(payload) {
        const bids = Array.isArray(payload?.bids) ? payload.bids : [];
        if (!bids.length) return null;
        const last = bids[bids.length - 1];
        const price = Number(last?.price);
        return Number.isFinite(price) ? price : null;
    }

    async function fetchOrderBookBestQuotes(tokenId, version) {
        if (!tokenId) {
            return null;
        }
        try {
            const res = await fetch(`${ORDERBOOK_API}/${encodeURIComponent(tokenId)}`);
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}`);
            }
            const data = await res.json();
            const price = extractBestAskFromOrderBook(data);
            const bid = extractBestBidFromOrderBook(data);
            setTokenBestAsk(tokenId, price, version);
            setTokenBestBid(tokenId, bid, version);
            return {bestAsk: price, bestBid: bid};
        } catch (err) {
            console.warn("Failed to fetch order book for", tokenId, err);
            setTokenBestAsk(tokenId, null, version);
            setTokenBestBid(tokenId, null, version);
            return null;
        }
    }

    function ensureOrderBooksForMarkets(markets) {
        if (!Array.isArray(markets) || !markets.length) return;
        const tokenIds = [];
        markets.forEach(item => {
            tokenIds.push(...getTokenIds(item));
        });
        ensureOrderBooksForTokens(tokenIds);
    }

    function ensureOrderBooksForTokens(tokenIds) {
        if (!Array.isArray(tokenIds) || !tokenIds.length) return;
        tokenIds.forEach(tokenId => {
            if (!tokenId) return;
            if (hasTokenBestQuotes(tokenId) || tokenOrderBookRequests.has(tokenId) || tokenOrderBookQueued.has(tokenId)) return;
            tokenOrderBookQueue.push(tokenId);
            tokenOrderBookQueued.add(tokenId);
        });
        drainOrderBookQueue();
    }

    function drainOrderBookQueue() {
        if (!tokenOrderBookQueue.length) return;
        while (tokenOrderBookRequests.size < ORDERBOOK_BATCH_SIZE && tokenOrderBookQueue.length) {
            const tokenId = tokenOrderBookQueue.shift();
            if (!tokenId) continue;
            tokenOrderBookQueued.delete(tokenId);
            if (hasTokenBestQuotes(tokenId) || tokenOrderBookRequests.has(tokenId)) continue;
            const version = orderBookVersion;
            const request = fetchOrderBookBestQuotes(tokenId, version).finally(() => {
                tokenOrderBookRequests.delete(tokenId);
                if (version === orderBookVersion) {
                    scheduleOrderBookDrivenRefresh();
                }
                drainOrderBookQueue();
            });
            tokenOrderBookRequests.set(tokenId, request);
        }
    }

    function scheduleOrderBookDrivenRefresh() {
        if (pendingOrderBookRefresh) return;
        pendingOrderBookRefresh = true;
        orderBookRefreshTimer = setTimeout(() => {
            pendingOrderBookRefresh = false;
            orderBookRefreshTimer = null;
            refreshView({skipChart: true});
        }, 0);
    }

    function extractOutcomePrice(item, index) {
        const prices = parseOutcomePrices(item?.outcomePrices);
        if (!prices || prices.length <= index) return null;
        const value = Number(prices[index]);
        if (!Number.isFinite(value)) return null;
        return value;
    }

    function buildHistoryKey(tokenId, interval) {
        return `${tokenId}::${interval}`;
    }

    function setHistoryPoints(tokenId, interval, history) {
        chartHistoryCache.set(buildHistoryKey(tokenId, interval), buildPoints(history));
    }

    function getHistoryPoints(tokenId, interval) {
        return chartHistoryCache.get(buildHistoryKey(tokenId, interval)) || null;
    }

    function hasHistory(tokenId, interval) {
        return chartHistoryCache.has(buildHistoryKey(tokenId, interval));
    }

    function resetChartCaches() {
        chartHistoryCache.clear();
        btcHistoryCache.clear();
        currentBtcCacheKey = null;
        currentBtcInterval = null;
        currentBtcBounds = null;
    }

    function pruneHistoryCache(validTokenIds) {
        const validSet = new Set(validTokenIds);
        for (const key of chartHistoryCache.keys()) {
            const [tokenId] = key.split("::");
            if (!validSet.has(tokenId)) {
                chartHistoryCache.delete(key);
            }
        }
    }

    function getCachedIntervalBounds(interval) {
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        chartTokens.forEach(token => {
            const points = getHistoryPoints(token.tokenId, interval);
            if (!points || !points.length) return;
            const firstTime = points[0].time;
            const lastTime = points[points.length - 1].time;
            if (firstTime < min) min = firstTime;
            if (lastTime > max) max = lastTime;
        });
        if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) return null;
        return {min, max};
    }

    function isValidBounds(bounds) {
        if (!bounds) return false;
        const {min, max} = bounds;
        return Number.isFinite(min) && Number.isFinite(max) && max - min >= BTC_INTERVAL_MS;
    }

    function buildBtcHistoryKey(interval, bounds) {
        if (!isValidBounds(bounds)) {
            return `${interval}::default`;
        }
        const startBucket = Math.floor(bounds.min / BTC_INTERVAL_MS);
        const endBucket = Math.floor(bounds.max / BTC_INTERVAL_MS);
        return `${interval}::${startBucket}::${endBucket}`;
    }

    function setBtcHistoryPoints(interval, bounds, history) {
        const key = buildBtcHistoryKey(interval, bounds);
        const points = buildPoints(history);
        btcHistoryCache.set(key, points);
        return key;
    }

    function getBtcHistoryPoints(interval) {
        if (!currentBtcCacheKey || currentBtcInterval !== interval) return null;
        return btcHistoryCache.get(currentBtcCacheKey) || null;
    }

    function hasBtcHistory(interval, bounds) {
        return btcHistoryCache.has(buildBtcHistoryKey(interval, bounds));
    }

    function syncChartTokens(tokens) {
        chartTokens = tokens;
        const validIds = new Set(tokens.map(token => token.tokenId));
        pruneHistoryCache(validIds);
        [...selectedChartTokenIds].forEach(id => {
            if (!validIds.has(id)) selectedChartTokenIds.delete(id);
        });
        if (!selectedChartTokenIds.size) {
            tokens.forEach(token => selectedChartTokenIds.add(token.tokenId));
        }
        renderChartTokenList();
    }

    function renderChartTokenList() {
        if (!chartTokenList) return;
        chartTokenList.innerHTML = "";
        if (!chartTokens.length) {
            const empty = document.createElement("div");
            empty.className = "chart-token-empty";
            empty.textContent = "暂无 YES token";
            chartTokenList.appendChild(empty);
            return;
        }
        chartTokens.forEach(token => {
            const item = document.createElement("div");
            item.className = "chart-token-item";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = selectedChartTokenIds.has(token.tokenId);
            checkbox.addEventListener("change", () => {
                handleTokenSelectionChange(token.tokenId, checkbox.checked);
            });

            const label = document.createElement("label");
            const title = document.createElement("strong");
            title.textContent = token.label;
            const subtitle = document.createElement("span");
            subtitle.textContent = token.question || token.ticker || token.tokenId;
            subtitle.title = token.question || token.ticker || token.tokenId;
            label.appendChild(title);
            label.appendChild(subtitle);

            item.appendChild(checkbox);
            item.appendChild(label);
        chartTokenList.appendChild(item);
    });
}

function handleTokenSelectionChange(tokenId, checked) {
        if (checked) {
            selectedChartTokenIds.add(tokenId);
        } else {
            selectedChartTokenIds.delete(tokenId);
        }
        renderChartTokenList();
        renderChartFromCache();
    }

    function buildDatasetsFromCache() {
        const selectedTokens = chartTokens.filter(token => selectedChartTokenIds.has(token.tokenId));
        const datasets = selectedTokens.map(token => {
            const points = getHistoryPoints(token.tokenId, chartInterval);
            if (!points || !points.length) return null;
            return {
                label: token.label,
                tokenId: token.tokenId,
                color: getChartColorForToken(token.tokenId),
                points,
            };
        }).filter(Boolean);
        let hasBtc = false;
        if (datasets.length) {
            const btcPoints = getBtcHistoryPoints(chartInterval);
            if (btcPoints && btcPoints.length) {
                datasets.push({
                    label: BTC_SERIES_LABEL,
                    tokenId: BTC_SERIES_ID,
                    color: BTC_SERIES_COLOR,
                    points: btcPoints,
                    scale: "btc",
                });
                hasBtc = true;
            }
        }
        return {datasets, totalCount: chartTokens.length, selectedCount: selectedTokens.length, hasBtc};
    }

    function getChartColorForToken(tokenId) {
        const index = chartTokens.findIndex(token => token.tokenId === tokenId);
        return getChartColor(index >= 0 ? index : chartTokens.length);
    }

    function renderChartFromCache({failureCount = 0, btcFailed = false} = {}) {
        const {datasets, totalCount, selectedCount} = buildDatasetsFromCache();
        let message;
        if (!totalCount) {
            message = "当前筛选下没有 YES token";
        } else if (!selectedCount) {
            message = `共 ${totalCount} 个 YES token，请至少选择 1 个`;
        } else if (!datasets.length) {
            message = `已选 ${selectedCount} 个，但暂无价格数据`;
        } else {
            if (selectedCount === datasets.length) {
                message = `已选 ${datasets.length}/${totalCount} 条曲线`;
            } else {
                message = `已选 ${selectedCount}/${totalCount} 个，绘制 ${datasets.length} 条`;
            }
        }
        if (failureCount) {
            message = `${message}，${failureCount} 个加载失败`;
        }
        if (btcFailed) {
            message = `${message}，BTC 曲线加载失败`;
        }
        setChartStatus(message);
        renderChart(datasets);
        renderChartLegend(datasets);
    }

    async function refreshYesTokenChart(markets = lastRenderedMarkets) {
        if (!chartCanvas || !chartStatusEl) return;
        lastRenderedMarkets = markets;
        const tokens = collectYesTokens(markets);
        syncChartTokens(tokens);
        if (!tokens.length) {
            setChartStatus("当前筛选下没有 YES token");
            renderChart([]);
            renderChartLegend([]);
            return;
        }
        if (chartAbortController) {
            chartAbortController.abort();
        }
        chartAbortController = new AbortController();
        const {signal} = chartAbortController;
        const requestId = ++chartRequestId;
        setChartStatus(`共 ${tokens.length} 个 YES token，加载价格数据…`);
        try {
            const {failureCount} = await loadHistoriesForTokens(tokens, chartInterval, signal);
            const cachedBounds = getCachedIntervalBounds(chartInterval);
            currentBtcInterval = chartInterval;
            currentBtcBounds = isValidBounds(cachedBounds) ? cachedBounds : null;
            currentBtcCacheKey = buildBtcHistoryKey(chartInterval, currentBtcBounds);
            const btcResult = await ensureBtcHistory(chartInterval, signal, currentBtcBounds);
            if (requestId !== chartRequestId) return;
            renderChartFromCache({failureCount, btcFailed: btcResult.failed});
        } catch (err) {
            if (err.name === "AbortError") return;
            console.error(err);
            setChartStatus("加载价格曲线失败");
            renderChart([]);
            renderChartLegend([]);
        }
    }

    async function loadHistoriesForTokens(tokens, interval, signal) {
        const pending = tokens.filter(token => !hasHistory(token.tokenId, interval));
        if (!pending.length) return {failureCount: 0};
        const tasks = pending.map(token =>
            fetchYesTokenHistory(token.tokenId, interval, signal)
                .then(history => ({token, history}))
                .catch(error => {
                    if (error?.name === "AbortError") throw error;
                    return {token, error, failed: true};
                })
        );
        const results = await Promise.all(tasks);
        let failureCount = 0;
        results.forEach(result => {
            if (result.failed) {
                failureCount++;
                console.error(`加载 YES token ${result.token.tokenId} 价格失败:`, result.error?.message || result.error);
                return;
            }
            setHistoryPoints(result.token.tokenId, interval, result.history);
        });
        return {failureCount};
    }

    async function ensureBtcHistory(interval, signal, bounds) {
        if (hasBtcHistory(interval, bounds)) return {failed: false};
        try {
            const history = await fetchBtcHistory(interval, bounds, signal);
            currentBtcCacheKey = setBtcHistoryPoints(interval, bounds, history);
            return {failed: false};
        } catch (err) {
            if (err.name === "AbortError") throw err;
            console.error("加载 BTC 价格失败:", err);
            return {failed: true};
        }
    }

    async function fetchBtcHistory(interval, bounds, signal) {
        const params = new URLSearchParams();
        params.append("interval", interval);
        if (isValidBounds(bounds)) {
            params.append("start", Math.floor(bounds.min));
            params.append("end", Math.floor(bounds.max));
        }
        const res = await fetch(`${BTC_HISTORY_API}?${params.toString()}`, {signal});
        if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.message || "请求失败");
        }
        const data = await res.json();
        return Array.isArray(data?.history) ? data.history : [];
    }

    async function fetchYesTokenHistory(tokenId, interval, signal) {
        const params = new URLSearchParams();
        params.append("market", tokenId);
        params.append("interval", interval);
        const res = await fetch(`${PRICE_HISTORY_API}?${params.toString()}`, {signal});
        if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.message || "请求失败");
        }
        const data = await res.json();
        return Array.isArray(data?.history) ? data.history : [];
    }

    function renderChartLegend(datasets) {
        if (!chartLegend) return;
        if (!datasets.length) {
            chartLegend.innerHTML = "";
            return;
        }
        chartLegend.innerHTML = datasets.map(({label, color, tokenId}) => `
            <div class="chart-legend-item">
                <span class="chart-legend-dot" style="background:${color}"></span>
                <span title="${tokenId}">${label}</span>
            </div>
        `).join("");
    }

    function setChartStatus(message) {
        if (chartStatusEl) chartStatusEl.textContent = message || "";
    }

    function setChartRangeLabel(start, end) {
        if (!chartRangeEl) return;
        if (!Number.isFinite(start) || !Number.isFinite(end)) {
            chartRangeEl.textContent = "";
            return;
        }
        chartRangeEl.textContent = `${formatChartTimestamp(start)} - ${formatChartTimestamp(end)}`;
    }

    function setChartWindowInfo(start, end) {
        if (!chartWindowInfo) return;
        if (!Number.isFinite(start) || !Number.isFinite(end)) {
            chartWindowInfo.textContent = "窗口：—";
            return;
        }
        const duration = formatDuration(end - start);
        const isFullRange = chartViewSpan >= 0.999 || (chartTimeBounds && chartTimeBounds.max <= chartTimeBounds.min);
        const label = isFullRange ? `窗口：全区间（${duration}）` : `窗口：${duration}`;
        chartWindowInfo.textContent = label;
    }

    function formatChartTimestamp(value) {
        if (!Number.isFinite(value)) return "";
        return chartDateFormatter.format(new Date(value));
    }

    function formatTimelineLabel(value) {
        if (!Number.isFinite(value)) return "";
        const date = new Date(value);
        return String(date.getHours()).padStart(2, "0");
    }

    function formatDuration(ms) {
        if (!Number.isFinite(ms) || ms <= 0) return "少于 1 分钟";
        const totalMinutes = Math.floor(ms / 60000);
        const days = Math.floor(totalMinutes / (60 * 24));
        const hours = Math.floor((totalMinutes % (60 * 24)) / 60);
        const minutes = totalMinutes % 60;
        const parts = [];
        if (days) parts.push(`${days}天`);
        if (hours) parts.push(`${hours}小时`);
        if (minutes && parts.length < 2) parts.push(`${minutes}分钟`);
        return parts.length ? parts.join("") : "少于 1 分钟";
    }

    function clampZoomSpan(value) {
        if (!Number.isFinite(value)) return CHART_ZOOM_MAX;
        return Math.min(CHART_ZOOM_MAX, Math.max(CHART_ZOOM_MIN, value));
    }


    function renderChart(datasets) {
        if (!chartCanvas) return;
        const usable = datasets.filter(dataset => dataset.points && dataset.points.length);
        if (!usable.length) {
            chartCanvas.style.display = "none";
            if (chartEmpty) chartEmpty.style.display = "flex";
            lastChartDatasets = [];
            chartTimeBounds = null;
            chartCurrentWindow = null;
            timelineDragState = null;
            setChartRangeLabel();
            setChartWindowInfo();
            drawTimeline();
            return;
        }
        lastChartDatasets = usable;
        chartTimeBounds = computeTimeBounds(usable);
        chartCanvas.style.display = "block";
        if (chartEmpty) chartEmpty.style.display = "none";
        drawChartWithView(usable);
    }

    function drawChartWithView(datasets) {
        const {series, viewWindow} = applyViewWindow(datasets);
        const hasPoints = series.some(dataset => dataset.points && dataset.points.length);
        if (!hasPoints) {
            chartRenderState = null;
            clearChartHover();
            chartCanvas.style.display = "none";
            if (chartEmpty) chartEmpty.style.display = "flex";
            setChartRangeLabel(viewWindow?.start, viewWindow?.end);
            setChartWindowInfo(viewWindow?.start, viewWindow?.end);
            return;
        }
        chartCanvas.style.display = "block";
        if (chartEmpty) chartEmpty.style.display = "none";
        drawChart(series);
        drawTimeline();
        const start = viewWindow?.start ?? chartTimeBounds?.min;
        const end = viewWindow?.end ?? chartTimeBounds?.max;
        setChartRangeLabel(start, end);
        setChartWindowInfo(start, end);
    }

    function computeTimeBounds(datasets) {
        const times = datasets.flatMap(set => (set.points || []).map(point => point.time));
        if (!times.length) return null;
        let min = times[0];
        let max = times[0];
        times.forEach(time => {
            if (time < min) min = time;
            if (time > max) max = time;
        });
        return {min, max};
    }

    function getViewWindowBounds() {
        if (!chartTimeBounds) return null;
        const {min, max} = chartTimeBounds;
        const totalRange = Math.max(1, max - min);
        if (chartViewSpan >= 0.999) {
            return {start: min, end: max};
        }
        const availableFraction = Math.max(0, 1 - chartViewSpan);
        const offsetFraction = availableFraction <= 0 ? 0 : chartViewOffsetRatio * availableFraction;
        const windowSpan = Math.max(1, totalRange * chartViewSpan);
        const maxStart = Math.max(min, max - windowSpan);
        const rawStart = min + totalRange * offsetFraction;
        const clampedStart = Math.min(Math.max(min, rawStart), maxStart);
        const windowEnd = Math.min(max, clampedStart + windowSpan);
        return {start: clampedStart, end: windowEnd};
    }

    function applyViewWindow(datasets) {
        const bounds = getViewWindowBounds();
        if (!bounds) {
            chartCurrentWindow = null;
            return {series: datasets, window: null};
        }
        chartCurrentWindow = bounds;
        if (chartViewSpan >= 0.999) {
            return {series: datasets, window: bounds};
        }
        const clipped = datasets.map(dataset => ({
            ...dataset,
            points: clipPointsToWindow(dataset.points, bounds.start, bounds.end),
        }));
        return {series: clipped, window: bounds};
    }

    function clipPointsToWindow(points = [], start, end) {
        if (!points.length) return [];
        const result = [];
        let lastBefore = null;
        let firstAfter = null;
        let addedBefore = false;
        for (const point of points) {
            if (point.time < start) {
                lastBefore = point;
                continue;
            }
            if (!addedBefore && lastBefore) {
                result.push(lastBefore);
                addedBefore = true;
            }
            if (point.time > end) {
                firstAfter = point;
                break;
            }
            result.push(point);
        }
        if (!result.length && lastBefore) {
            result.push(lastBefore);
        }
        if (firstAfter) {
            result.push(firstAfter);
        } else if (!result.length) {
            result.push(points[points.length - 1]);
        }
        return result;
    }

    function redrawChartWithCurrentView() {
        if (!lastChartDatasets.length) {
            drawTimeline();
            return;
        }
        drawChartWithView(lastChartDatasets);
    }

    function drawChart(series) {
        if (!chartCanvas) return;
        const ctx = chartCanvas.getContext("2d");
        if (!ctx) return;
        chartRenderState = null;
        clearChartHover();
        const ratio = window.devicePixelRatio || 1;
        const width = chartCanvas.clientWidth || chartCanvas.width;
        chartCanvas.width = width * ratio;
        chartCanvas.height = TOTAL_CANVAS_HEIGHT * ratio;
        chartCanvas.style.width = `${width}px`;
        chartCanvas.style.height = `${TOTAL_CANVAS_HEIGHT}px`;
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        ctx.clearRect(0, 0, width, TOTAL_CANVAS_HEIGHT);

        const padding = {top: 18, right: 84, bottom: 28, left: 56};
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = MAIN_CHART_HEIGHT - padding.top - padding.bottom;

        const times = Array.from(new Set(series.flatMap(set => set.points.map(p => p.time)))).sort((a, b) => a - b);
        if (!times.length) return;
        const timeMin = times[0];
        const timeMax = times[times.length - 1] || (timeMin + 1);
        const timeRange = timeMax - timeMin || 1;
        const priceMin = 0;
        const priceMax = 1;
        const priceRange = priceMax - priceMin || 1;

        const clampPrice = price => Math.min(priceMax, Math.max(priceMin, price));
        const xFor = time => padding.left + ((time - timeMin) / timeRange) * chartWidth;
        const yForPrimary = price => padding.top + chartHeight * (1 - (clampPrice(price) - priceMin) / priceRange);
        const secondaryScale = computeSecondaryScale(series);
        const yForSecondary = secondaryScale
            ? (price => {
                const clamped = Math.min(secondaryScale.max, Math.max(secondaryScale.min, price));
                const range = secondaryScale.max - secondaryScale.min || 1;
                return padding.top + chartHeight * (1 - (clamped - secondaryScale.min) / range);
            })
            : null;
        drawGrid(ctx, padding, chartWidth, chartHeight, priceMin, priceMax, secondaryScale);
        const renderedSeries = [];
        series.forEach(set => {
            const yAccessor = set.scale === "btc" && yForSecondary ? yForSecondary : yForPrimary;
            drawLineSeries(ctx, set, xFor, yAccessor, padding, chartHeight, renderedSeries);
        });
        chartRenderState = {
            width,
            padding,
            chartWidth,
            chartHeight,
            areaTop: 0,
            areaBottom: MAIN_CHART_HEIGHT,
            timeMin,
            timeMax,
            timeRange,
            priceMin,
            priceMax,
            priceRange,
            secondaryScale,
            series: renderedSeries,
        };
    }

    function drawTimeline() {
        if (!chartCanvas) return;
        const ctx = chartCanvas.getContext("2d");
        if (!ctx) return;
        const width = chartCanvas.clientWidth || chartCanvas.width;
        const metrics = getTimelineMetrics(width);
        drawTimelineBackground(ctx, metrics);

        if (!chartTimeBounds) {
            drawTimelineEmpty(ctx, metrics);
            return;
        }

        const viewWindow = getViewWindowBounds();
        if (viewWindow) {
            const range = Math.max(1, chartTimeBounds.max - chartTimeBounds.min);
            const startRatio = (viewWindow.start - chartTimeBounds.min) / range;
            const endRatio = (viewWindow.end - chartTimeBounds.min) / range;
            drawTimelineSelection(ctx, metrics, startRatio, endRatio);
        }
        drawTimelineTicks(ctx, metrics, chartTimeBounds.min, chartTimeBounds.max);
    }

    function drawTimelineBackground(ctx, metrics) {
        const top = metrics.top;
        const gradient = ctx.createLinearGradient(0, top, 0, top + metrics.height);
        gradient.addColorStop(0, "rgba(56,189,248,0.25)");
        gradient.addColorStop(1, "rgba(15,20,28,0.8)");
        ctx.fillStyle = gradient;
        ctx.fillRect(metrics.padding, top, metrics.usableWidth, metrics.height);

        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 1;
        ctx.strokeRect(metrics.padding, top, metrics.usableWidth, metrics.height);
    }

    function drawTimelineEmpty(ctx, metrics) {
        drawTimelineBackground(ctx, metrics);
        ctx.fillStyle = "#94a3b8";
        ctx.font = "12px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("等待数据加载…", metrics.padding + metrics.usableWidth / 2, metrics.top + metrics.height / 2);
    }

    function getTimelineMetrics(widthOverride) {
        const width = widthOverride ?? (chartCanvas?.clientWidth || chartCanvas?.width || 800);
        const padding = TIMELINE_PADDING;
        const usableWidth = Math.max(1, width - padding * 2);
        const top = MAIN_CHART_HEIGHT + TIMELINE_GAP;
        return {width, height: TIMELINE_HEIGHT, padding, usableWidth, top};
    }

    function drawTimelineSelection(ctx, metrics, startRatio, endRatio) {
        const startClamped = Math.max(0, Math.min(1, startRatio));
        const endClamped = Math.max(0, Math.min(1, endRatio));
        const rawStartX = ratioToTimelineX(startClamped, metrics);
        const rawEndX = ratioToTimelineX(endClamped, metrics);
        const left = Math.min(rawStartX, rawEndX);
        const right = Math.max(rawStartX, rawEndX);
        const selectionWidth = Math.max(6, right - left);
        ctx.fillStyle = "rgba(56,189,248,0.12)";
        ctx.fillRect(left, metrics.top + 4, selectionWidth, metrics.height - 8);
        ctx.strokeStyle = "#38bdf8";
        ctx.lineWidth = 2;
        ctx.strokeRect(left, metrics.top + 4, selectionWidth, metrics.height - 8);
        [rawStartX, rawEndX].forEach(x => {
            ctx.fillStyle = "#38bdf8";
            ctx.fillRect(x - 4, metrics.top + 4, 8, metrics.height - 8);
        });
    }

    function drawTimelineTicks(ctx, metrics, minTime, maxTime) {
        if (!Number.isFinite(minTime) || !Number.isFinite(maxTime) || maxTime <= minTime) return;
        const {primaryInterval, secondaryInterval} = chooseTimelineIntervals(minTime, maxTime, metrics.usableWidth);
        drawTimelineTickLayer(ctx, metrics, minTime, maxTime, primaryInterval, true);
        if (secondaryInterval) {
            drawTimelineTickLayer(ctx, metrics, minTime, maxTime, secondaryInterval, false);
        }
    }

    function drawTimelineTickLayer(ctx, metrics, minTime, maxTime, intervalMs, emphasize) {
        if (!intervalMs || intervalMs <= 0) return;
        const range = maxTime - minTime;
        const startTime = Math.ceil(minTime / intervalMs) * intervalMs;
        ctx.font = emphasize ? "11px system-ui" : "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        for (let time = startTime; time <= maxTime; time += intervalMs) {
            const ratio = (time - minTime) / range;
            const x = metrics.padding + ratio * metrics.usableWidth;
            ctx.fillStyle = emphasize ? "rgba(255,255,255,0.45)" : "rgba(255,255,255,0.25)";
            const tickHeight = emphasize ? 22 : 14;
            ctx.fillRect(x - 0.5, metrics.top + metrics.height - 4 - tickHeight, 1, tickHeight);
            if (emphasize) {
                ctx.fillStyle = "#cbd5f5";
                ctx.fillText(formatTimelineLabel(time), x, metrics.top + metrics.height - 6);
            }
        }
    }

    function chooseTimelineIntervals(minTime, maxTime, width) {
        const range = maxTime - minTime;
        if (range <= 0) return {primaryInterval: 0, secondaryInterval: 0};
        const targetTickCount = Math.max(10, Math.min(16, Math.floor(width / 100)));
        let intervalMs = snapInterval(range / targetTickCount);
        let tickCount = Math.floor(range / intervalMs);
        while (tickCount < 10 && intervalMs > SNAP_INTERVALS[0]) {
            const next = Math.max(SNAP_INTERVALS[0], intervalMs / 2);
            if (next === intervalMs) break;
            intervalMs = next;
            tickCount = Math.floor(range / intervalMs);
        }
        const secondary = intervalMs >= 2 * SNAP_INTERVALS[0] ? Math.max(SNAP_INTERVALS[0], intervalMs / 2) : 0;
        return {primaryInterval: intervalMs, secondaryInterval: secondary};
    }

    const SNAP_INTERVALS = [
        60 * 1000,
        5 * 60 * 1000,
        10 * 60 * 1000,
        15 * 60 * 1000,
        30 * 60 * 1000,
        60 * 60 * 1000,
        2 * 60 * 60 * 1000,
        6 * 60 * 60 * 1000,
        12 * 60 * 60 * 1000,
        24 * 60 * 60 * 1000,
        3 * 24 * 60 * 60 * 1000,
        7 * 24 * 60 * 60 * 1000,
        14 * 24 * 60 * 60 * 1000,
        30 * 24 * 60 * 60 * 1000,
    ];

    function snapInterval(value) {
        for (const option of SNAP_INTERVALS) {
            if (value <= option) return option;
        }
        return SNAP_INTERVALS[SNAP_INTERVALS.length - 1];
    }

    function getTimelinePosition(event, metrics = getTimelineMetrics()) {
        if (!chartCanvas) return {x: 0, y: 0};
        const rect = chartCanvas.getBoundingClientRect();
        return {
            x: Math.max(0, Math.min(metrics.width, event.clientX - rect.left)),
            y: event.clientY - rect.top,
        };
    }

    function ratioToTimelineX(ratio, metrics) {
        return metrics.padding + Math.max(0, Math.min(1, ratio)) * metrics.usableWidth;
    }

    function positionToTimelineRatio(x, metrics) {
        return Math.max(0, Math.min(1, (x - metrics.padding) / metrics.usableWidth));
    }

    function getWindowRatios() {
        if (!chartTimeBounds) return {start: 0, end: 1};
        const bounds = getViewWindowBounds() || {start: chartTimeBounds.min, end: chartTimeBounds.max};
        const range = Math.max(1, chartTimeBounds.max - chartTimeBounds.min);
        const startRatio = (bounds.start - chartTimeBounds.min) / range;
        const endRatio = (bounds.end - chartTimeBounds.min) / range;
        return {
            start: Math.max(0, Math.min(1, startRatio)),
            end: Math.max(0, Math.min(1, endRatio)),
        };
    }

    function isPointInTimeline(y, metrics = getTimelineMetrics()) {
        return y >= metrics.top && y <= metrics.top + metrics.height;
    }

    function updateOffsetFromStartRatio(startRatio) {
        const available = Math.max(0, 1 - chartViewSpan);
        if (available <= 0) {
            chartViewOffsetRatio = 0;
            return;
        }
        const normalized = Number.isFinite(startRatio) ? startRatio : 0;
        chartViewOffsetRatio = Math.max(0, Math.min(1, normalized / available));
    }

    function clampStartRatio(value) {
        const maxStart = Math.max(0, 1 - chartViewSpan);
        const normalized = Number.isFinite(value) ? value : 0;
        return Math.max(0, Math.min(maxStart, normalized));
    }

    function drawGrid(ctx, padding, width, height, priceMin, priceMax, secondaryScale) {
        const steps = PRICE_GRID_STEPS; // e.g. 0.05 increments across [0, 1]
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 6]);
        ctx.beginPath();
        for (let i = 0; i <= steps; i++) {
            const y = padding.top + (height / steps) * i;
            ctx.moveTo(padding.left, y);
            ctx.lineTo(padding.left + width, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        ctx.save();
        ctx.fillStyle = "#94a3b8";
        ctx.font = "12px system-ui";
        for (let i = 0; i <= steps; i++) {
            const price = priceMax - ((priceMax - priceMin) / steps) * i;
            const y = padding.top + (height / steps) * i;
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.fillText(formatPrice(price, {fallback: ""}), padding.left - 6, y);
            if (secondaryScale) {
                const secondaryValue = secondaryScale.max - ((secondaryScale.max - secondaryScale.min) / steps) * i;
                ctx.textAlign = "left";
                ctx.fillText(formatBtcAxisValue(secondaryValue), padding.left + width + 6, y);
            }
        }
        if (secondaryScale) {
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText(secondaryScale.label || BTC_AXIS_LABEL, padding.left + width + 6, padding.top);
        }
        ctx.restore();
    }

    function formatBtcAxisValue(value) {
        if (!Number.isFinite(value)) return "";
        const abs = Math.abs(value);
        if (abs >= 100000) return value.toFixed(0);
        if (abs >= 1000) return Math.round(value).toLocaleString("en-US");
        if (abs >= 100) return value.toFixed(1);
        return value.toFixed(2);
    }

    function computeSecondaryScale(series) {
        const values = series
            .filter(dataset => dataset.scale === "btc")
            .flatMap(dataset => (dataset.points || []).map(point => point.price))
            .filter(value => Number.isFinite(value));
        if (!values.length) return null;
        let min = values[0];
        let max = values[0];
        values.forEach(value => {
            if (value < min) min = value;
            if (value > max) max = value;
        });
        if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
        if (min === max) {
            const delta = Math.max(1, Math.abs(min) * 0.01 || 1);
            min -= delta;
            max += delta;
        } else {
            const pad = Math.max(1, (max - min) * 0.05);
            min -= pad;
            max += pad;
        }
        return {min, max, label: BTC_AXIS_LABEL};
    }

    function drawLineSeries(ctx, series, xFor, yFor, padding, chartHeight, renderedSeries) {
        const pixelPoints = [];
        ctx.beginPath();
        ctx.strokeStyle = series.color;
        ctx.lineWidth = 2;
        series.points.forEach((point, idx) => {
            const x = xFor(point.time);
            const y = yFor(point.price);
            pixelPoints.push({time: point.time, price: point.price, x, y});
            if (idx === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        drawSeriesLabel(ctx, series, xFor, yFor, padding, chartHeight);
        if (renderedSeries) {
            renderedSeries.push({
                tokenId: series.tokenId,
                label: series.label,
                color: series.color,
                scale: series.scale,
                points: pixelPoints,
            });
        }
    }

    function drawSeriesLabel(ctx, series, xFor, yFor, padding, chartHeight) {
        const lastPoint = series.points[series.points.length - 1];
        if (!lastPoint) return;
        const x = xFor(lastPoint.time) + 6;
        const y = yFor(lastPoint.price);
        const minY = padding.top + 8;
        const maxY = padding.top + chartHeight - 8;
        const clampedY = Math.max(minY, Math.min(maxY, y));
        ctx.font = "12px system-ui";
        ctx.fillStyle = series.color;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText(series.label, x, clampedY);
    }

    function handleChartPointerMove(event) {
        if (!chartRenderState || !chartCanvas || timelineDragState) return;
        const pos = getChartPointerPosition(event);
        if (!isPointInChartArea(pos.y)) {
            clearChartHover();
            return;
        }
        const target = findChartHoverTarget(pos);
        if (target) {
            applyChartHover(target, pos);
        } else {
            clearChartHover();
        }
    }

    function handleChartPointerDown(event) {
        if (!chartRenderState || !chartCanvas) return;
        const pos = getChartPointerPosition(event);
        if (!isPointInChartArea(pos.y) || isPointInTimeline(pos.y)) return;
        const target = findChartHoverTarget(pos);
        if (target) {
            applyChartHover(target, pos);
        } else {
            clearChartHover();
        }
    }

    function handleChartPointerLeave() {
        clearChartHover();
    }

    function getChartPointerPosition(event) {
        if (!chartCanvas) return {x: 0, y: 0};
        const rect = chartCanvas.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
        };
    }

    function isPointInChartArea(y) {
        return y >= 0 && y <= MAIN_CHART_HEIGHT;
    }

    function findChartHoverTarget(pos) {
        if (!chartRenderState?.series?.length) return null;
        const {series} = chartRenderState;
        let nearest = null;
        series.forEach(dataset => {
            if (!dataset?.points?.length) return;
            const candidate = findNearestPointByX(dataset.points, pos.x);
            if (!candidate) return;
            const distance = Math.hypot(candidate.x - pos.x, candidate.y - pos.y);
            if (distance > CHART_HOVER_MAX_DISTANCE) return;
            if (!nearest || distance < nearest.distance) {
                nearest = {dataset, point: candidate, distance};
            }
        });
        return nearest;
    }

    function findNearestPointByX(points, targetX) {
        if (!points.length) return null;
        let left = 0;
        let right = points.length - 1;
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (points[mid].x < targetX) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        const candidates = [points[left]];
        if (left > 0) candidates.push(points[left - 1]);
        if (left + 1 < points.length) candidates.push(points[left + 1]);
        let best = null;
        candidates.forEach(point => {
            if (!point) return;
            if (!best || Math.abs(point.x - targetX) < Math.abs(best.x - targetX)) {
                best = point;
            }
        });
        return best;
    }

    function applyChartHover(target, pointer) {
        if (!chartHoverLabel || !chartRenderState) return;
        const {dataset, point} = target;
        const width = chartCanvas?.clientWidth || chartRenderState.width || 0;
        const clampedX = Math.max(16, Math.min(width - 16, pointer.x));
        const clampedY = Math.max(16, Math.min(MAIN_CHART_HEIGHT - 16, pointer.y));
        if (chartHoverLabelTitle) chartHoverLabelTitle.textContent = dataset.label || "—";
        if (chartHoverLabelTime) chartHoverLabelTime.textContent = formatChartTimestamp(point.time);
        if (chartHoverLabelPrice) chartHoverLabelPrice.textContent = `价格：${formatChartHoverPrice(dataset, point.price)}`;
        chartHoverLabel.style.left = `${clampedX}px`;
        chartHoverLabel.style.top = `${clampedY}px`;
        chartHoverLabel.classList.add("active");
        chartHoverLabel.setAttribute("aria-hidden", "false");
        chartHoverData = {
            tokenId: dataset.tokenId || dataset.label,
            time: point.time,
            price: point.price,
            x: clampedX,
            y: clampedY,
        };
    }

    function clearChartHover() {
        if (!chartHoverLabel) return;
        chartHoverData = null;
        chartHoverLabel.classList.remove("active");
        chartHoverLabel.setAttribute("aria-hidden", "true");
        chartHoverLabel.style.left = "-9999px";
        chartHoverLabel.style.top = "-9999px";
    }

    function formatChartHoverPrice(dataset, price) {
        if (dataset.scale === "btc") {
            const value = Number(price);
            return Number.isFinite(value) ? `${formatBtcAxisValue(value)} USDT` : "—";
        }
        return formatPrice(price) || "—";
    }

    function handleTimelinePointerDown(event) {
        if (!chartCanvas || !chartTimeBounds) return;
        const metrics = getTimelineMetrics();
        const pos = getTimelinePosition(event, metrics);
        if (!isPointInTimeline(pos.y, metrics)) return;
        event.preventDefault();
        const ratios = getWindowRatios();
        const startRatio = ratios.start;
        const endRatio = ratios.end;
        const handleSize = 12;
        const startX = ratioToTimelineX(startRatio, metrics);
        const endX = ratioToTimelineX(endRatio, metrics);
        let mode = "move";
        if (Math.abs(pos.x - startX) <= handleSize) {
            mode = "resize-start";
        } else if (Math.abs(pos.x - endX) <= handleSize) {
            mode = "resize-end";
        } else if (pos.x < startX || pos.x > endX) {
            mode = "jump";
        }
        if (mode === "jump") {
            jumpTimelineToPosition(pos.x, metrics);
            return;
        }
        timelineDragState = {
            pointerId: event.pointerId,
            mode,
            metrics,
            originX: pos.x,
            initialStartRatio: startRatio,
            initialEndRatio: endRatio,
        };
        chartCanvas.setPointerCapture(event.pointerId);
    }

    function handleTimelinePointerMove(event) {
        if (!timelineDragState || timelineDragState.pointerId !== event.pointerId) return;
        const metrics = timelineDragState.metrics;
        const pos = getTimelinePosition(event, metrics);
        const deltaRatio = (pos.x - timelineDragState.originX) / metrics.usableWidth;
        applyTimelineDrag(deltaRatio);
    }

    function handleTimelinePointerUp(event) {
        if (chartCanvas?.hasPointerCapture?.(event.pointerId)) {
            chartCanvas.releasePointerCapture(event.pointerId);
        }
        timelineDragState = null;
    }

    function applyTimelineDrag(deltaRatio) {
        if (!timelineDragState) return;
        const state = timelineDragState;
        if (state.mode === "move") {
            const newStart = clampStartRatio(state.initialStartRatio + deltaRatio);
            updateOffsetFromStartRatio(newStart);
        } else if (state.mode === "resize-start") {
            let newStart = state.initialStartRatio + deltaRatio;
            const maxStart = state.initialEndRatio - CHART_ZOOM_MIN;
            newStart = Math.min(newStart, maxStart);
            newStart = Math.max(0, newStart);
            const newSpan = state.initialEndRatio - newStart;
            chartViewSpan = clampZoomSpan(newSpan);
            const adjustedStart = clampStartRatio(newStart);
            updateOffsetFromStartRatio(adjustedStart);
        } else if (state.mode === "resize-end") {
            let newEnd = state.initialEndRatio + deltaRatio;
            newEnd = Math.max(state.initialStartRatio + CHART_ZOOM_MIN, newEnd);
            newEnd = Math.min(1, newEnd);
            const newSpan = newEnd - state.initialStartRatio;
            chartViewSpan = clampZoomSpan(newSpan);
            const adjustedStart = clampStartRatio(state.initialStartRatio);
            updateOffsetFromStartRatio(adjustedStart);
        }
        redrawChartWithCurrentView();
    }

    function jumpTimelineToPosition(x, metrics) {
        if (!chartTimeBounds) return;
        const targetRatio = positionToTimelineRatio(x, metrics);
        const centeredStart = clampStartRatio(targetRatio - chartViewSpan / 2);
        updateOffsetFromStartRatio(centeredStart);
        redrawChartWithCurrentView();
    }

    function buildPoints(history) {
        return history.slice().sort((a, b) => a.t - b.t).map(entry => ({
            time: normalizeTimestamp(entry.t),
            price: Number(entry.p),
        })).filter(point => Number.isFinite(point.time) && Number.isFinite(point.price));
    }

    function normalizeTimestamp(value) {
        const num = Number(value);
        if (Number.isNaN(num)) return Date.now();
        return num > 1e12 ? num : num * 1000;
    }

    async function safeJson(res) {
        try {
            return await res.json();
        } catch (_) {
            return null;
        }
    }

    function getChartColor(index) {
        if (CHART_COLORS[index]) return CHART_COLORS[index];
        const hue = (index * 47) % 360;
        return `hsl(${hue} 70% 60%)`;
    }

    TAG_OPTIONS.forEach(option => {
        if (!tagSelect) return;
        const opt = document.createElement("option");
        opt.value = String(option.id);
        opt.textContent = `${option.label}`;
        tagSelect.appendChild(opt);
    });
    if (tagSelect) tagSelect.value = String(currentTagId);
    if (eventSelect) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "加载事件…";
        opt.disabled = true;
        opt.selected = true;
        eventSelect.appendChild(opt);
        eventSelect.disabled = true;
    }

    if (chartIntervalSelect) {
        CHART_INTERVALS.forEach(({value, label}) => {
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            chartIntervalSelect.appendChild(opt);
        });
        chartIntervalSelect.value = chartInterval;
        chartIntervalSelect.addEventListener("change", () => {
            chartInterval = chartIntervalSelect.value;
            refreshYesTokenChart(lastRenderedMarkets);
        });
    }
    if (chartCanvas) {
        chartCanvas.addEventListener("pointerdown", handleTimelinePointerDown);
        chartCanvas.addEventListener("pointermove", handleTimelinePointerMove);
        chartCanvas.addEventListener("pointerup", handleTimelinePointerUp);
        chartCanvas.addEventListener("pointercancel", handleTimelinePointerUp);
        chartCanvas.addEventListener("pointerleave", handleTimelinePointerUp);
        chartCanvas.addEventListener("pointermove", handleChartPointerMove);
        chartCanvas.addEventListener("pointerdown", handleChartPointerDown);
        chartCanvas.addEventListener("pointerleave", handleChartPointerLeave);
    }
    if (chartSelectAllBtn) {
        chartSelectAllBtn.addEventListener("click", () => {
            chartTokens.forEach(token => selectedChartTokenIds.add(token.tokenId));
            renderChartTokenList();
            renderChartFromCache();
        });
    }
    if (chartClearAllBtn) {
        chartClearAllBtn.addEventListener("click", () => {
            selectedChartTokenIds.clear();
            renderChartTokenList();
            renderChartFromCache();
        });
    }

    function getTagLabel(tagId) {
        const option = TAG_OPTIONS.find(opt => opt.id === tagId);
        return option ? option.label : null;
    }

    async function fetchMarkets(tagId) {
        const query = Number.isFinite(tagId) ? `?tag=${encodeURIComponent(tagId)}` : "";
        const res = await fetch(`${API}${query}`);
        if (!res.ok) throw new Error("网络请求失败");
        const payload = await res.json();
        const list = Array.isArray(payload) ? payload : [];
        return list;
    }

    function render(data) {
        const tbody = $("rows");
        tbody.innerHTML = "";
        data.forEach(item => {
            const tr = document.createElement("tr");
            fields.forEach(f => {
                const td = document.createElement("td");
                td.dataset.th = f.label;
                if (f.className) td.classList.add(f.className);
                const span = document.createElement("span");
                span.className = "cell-value";
                const value = formatValue(item[f.key], f);
                span.textContent = value;
                if (f.key === "question" && typeof value === "string") {
                    span.title = value;
                } else if (dateFieldRegex.test(f.key) && typeof value === "string") {
                    span.title = value;
                } else if (f.key === "outcomes") {
                    const parsed = parseOutcomes(item[f.key]);
                    if (parsed) {
                        span.title = parsed.join(" / ");
                    } else if (typeof item[f.key] === "string") {
                        span.title = item[f.key];
                    }
                }
                td.appendChild(span);
                tr.appendChild(td);
            });
            const detailTd = document.createElement("td");
            detailTd.dataset.th = "详细";
            const btn = document.createElement("button");
            btn.className = "detail-trigger";
            btn.textContent = "查看";
            btn.addEventListener("click", () => showDetail(item));
            detailTd.appendChild(btn);
            tr.appendChild(detailTd);
            const goTd = document.createElement("td");
            goTd.dataset.th = "前往";
            const slug = getPrimaryEventSlug(item);
            if (slug) {
                const link = document.createElement("a");
                link.href = `${POLY_EVENT_BASE_URL}${encodeURIComponent(slug)}`;
                link.target = "_blank";
                link.rel = "noopener noreferrer";
                link.textContent = "前往";
                goTd.appendChild(link);
            } else {
                goTd.textContent = "—";
            }
            tr.appendChild(goTd);
            const orderTd = document.createElement("td");
            orderTd.dataset.th = "下单";
            const orderBtn = document.createElement("button");
            orderBtn.className = "detail-trigger";
            orderBtn.textContent = "下单";
            orderBtn.addEventListener("click", () => openOrderPanel(item));
            orderTd.appendChild(orderBtn);
            tr.appendChild(orderTd);
            tbody.appendChild(tr);
        });
    }

    function pickDetail(item) {
        return detailKeys.reduce((acc, key) => {
            if (item[key] === undefined) return acc;
            if (key === "events" && Array.isArray(item.events)) {
                acc[key] = item.events.map(evt => {
                    return eventDetailKeys.reduce((evtAcc, evtKey) => {
                        if (evt && evt[evtKey] !== undefined) evtAcc[evtKey] = evt[evtKey];
                        return evtAcc;
                    }, {});
                });
                return acc;
            }
            acc[key] = item[key];
            return acc;
        }, {});
    }

    function showDetail(item) {
        const panel = $("detailPanel");
        const title = $("detailTitle");
        const json = $("detailJson");
        const filtered = pickDetail(item);
        title.textContent = filtered.question || filtered.id || "详情";
        json.textContent = JSON.stringify(filtered, null, 2);
        panel.classList.add("active");
    }

    function hideDetail() {
        $("detailPanel").classList.remove("active");
    }

    function getTokenOptions(item) {
        const tokens = getTokenIds(item);
        const outcomes = parseOutcomes(item?.outcomes);
        return tokens.map((tokenId, idx) => ({
            tokenId,
            label: outcomes && outcomes[idx] ? outcomes[idx] : idx === 0 ? "YES" : "NO",
            bestAsk: resolveBestAskForToken(tokenId, extractOutcomePrice(item, idx)),
        }));
    }

    function updateOrderTokenOptions(item) {
        if (!orderTokenGroup) return;
        const options = getTokenOptions(item);
        orderTokenGroup.innerHTML = "";
        options.forEach((opt, idx) => {
            const wrapper = document.createElement("label");
            wrapper.className = "order-token-option";
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = "orderTokenChoice";
            radio.value = opt.tokenId;
            if (opt.bestAsk !== null && opt.bestAsk !== undefined) {
                radio.dataset.bestAsk = String(opt.bestAsk);
            }
            radio.dataset.label = opt.label;
            if (idx === 1 || (idx === 0 && options.length === 1)) {
                radio.checked = true;
            }
            radio.addEventListener("change", () => updateOrderBestAskDisplay({writeToInput: true}));
            const span = document.createElement("span");
            span.textContent = `${opt.label} (${shorten(opt.tokenId)})`;
            wrapper.appendChild(radio);
            wrapper.appendChild(span);
            orderTokenGroup.appendChild(wrapper);
        });
        updateOrderBestAskDisplay({writeToInput: true});
    }

    function formatBestAsk(value) {
        return formatPrice(value);
    }

    function formatPriceInput(value) {
        return formatPrice(value, {fallback: "", withUnit: false});
    }

    function parsePriceInput(value) {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric / PRICE_DISPLAY_MULTIPLIER : Number.NaN;
    }

    function updateOrderBestAskDisplay({writeToInput = false} = {}) {
        if ((!orderBestAskEl && !writeToInput) || !orderTokenGroup) return;
        const selected = orderTokenGroup.querySelector("input[name='orderTokenChoice']:checked");
        if (!selected) {
            if (orderBestAskEl) orderBestAskEl.textContent = "—";
            if (writeToInput && orderBuyPriceInput) orderBuyPriceInput.value = "";
            return;
        }
        const bestAsk = Number(selected.dataset.bestAsk);
        const display = Number.isFinite(bestAsk) ? formatBestAsk(bestAsk) : "—";
        if (orderBestAskEl) orderBestAskEl.textContent = display;
        if (writeToInput && orderBuyPriceInput) {
            orderBuyPriceInput.value = Number.isFinite(bestAsk) ? formatPriceInput(bestAsk) : "";
        }
    }

    function openOrderPanel(item) {
        if (!orderPanel) return;
        const tokens = getTokenIds(item);
        if (!tokens.length) {
            setOrderStatus("无法获取 token，暂时无法下单", true);
            orderPanel.classList.add("active");
            return;
        }
        ensureOrderBooksForTokens(tokens);
        currentOrderContext = {
            question: item.question || "",
            slug: getPrimaryEventSlug(item),
            item,
        };
        orderQuestionEl.textContent = currentOrderContext.question || "—";
        orderEventSlugEl.textContent = currentOrderContext.slug || "—";
        orderBuyPriceInput.value = "";
        orderSizeInput.value = "";
        orderTakeProfitInput.value = "";
        setOrderStatus("");
        updateOrderTokenOptions(item);
        orderPanel.classList.add("active");
        orderBuyPriceInput.focus();
    }

    function closeOrderPanel() {
        if (!orderPanel) return;
        orderPanel.classList.remove("active");
        currentOrderContext = null;
        setOrderStatus("");
    }

    function setOrderStatus(message, isError = false) {
        if (!orderStatusEl) return;
        orderStatusEl.textContent = message || "";
        orderStatusEl.style.color = isError ? "#f87171" : "var(--muted)";
    }

    async function submitOrderRequest(payload, signal) {
        const res = await fetch("/api/place-order", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(payload),
            signal,
        });
        if (!res.ok) {
            const data = await safeJson(res);
            throw new Error(data?.message || "下单失败");
        }
        return res.json();
    }

    function showOrderToast({title = "提示", message = "", actionLabel, onAction}) {
        if (!orderToastContainer) return;
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.innerHTML = `
            <strong>${title}</strong>
            <div>${message}</div>
        `;
        if (actionLabel && typeof onAction === "function") {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = actionLabel;
            btn.addEventListener("click", () => {
                onAction();
                toast.remove();
            });
            toast.appendChild(btn);
        }
        orderToastContainer.appendChild(toast);
        setTimeout(() => {
            toast.remove();
        }, 4000);
    }

    function updateStatus(visibleCount) {
        if (!statusEl) return;
        if (!currentData.length) {
            const label = getTagLabel(currentTagId);
            statusEl.textContent = label ? `暂无 ${label} 数据` : "暂无数据";
            return;
        }
        const label = getTagLabel(currentTagId);
        const parts = [
            `已载入 ${currentData.length} 条`,
            `显示 ${visibleCount} 条`,
        ];
        if (label) parts.push(`标签：${label}`);
        if (currentEventTicker) parts.push(`事件：${currentEventTicker}`);
        statusEl.textContent = parts.join("，");
    }

    function refreshView({skipChart = false} = {}) {
        const outcomeFiltered = filterByOutcomeMode(currentData);
        updateEventFilterOptions(outcomeFiltered);
        const byEvent = filterByEvent(outcomeFiltered);
        const sorted = sortMarkets(byEvent);
        const enriched = enrichMarketStats(sorted);
        render(enriched);
        updateStatus(sorted.length);
        lastRenderedMarkets = sorted;
        ensureOrderBooksForMarkets(sorted);
        if (!skipChart) {
            refreshYesTokenChart(sorted);
        }
    }

    function normalizeTagId(tagId) {
        const matched = TAG_OPTIONS.find(opt => opt.id === tagId);
        return matched ? matched.id : DEFAULT_TAG_ID;
    }

    async function load(tagId = currentTagId, options = {}) {
        const {forceChartReload = false} = options;
        currentTagId = normalizeTagId(tagId);
        if (tagSelect) tagSelect.value = String(currentTagId);
        statusEl.textContent = "加载中…";
        reloadBtn.disabled = true;
        outcomeToggleBtn.disabled = true;
        if (tagSelect) tagSelect.disabled = true;
        if (eventSelect) eventSelect.disabled = true;
        if (forceChartReload) {
            resetChartCaches();
            if (chartAbortController) {
                chartAbortController.abort();
                chartAbortController = null;
            }
        }
        try {
            orderBookVersion += 1;
            tokenBestAskCache.clear();
            tokenBestBidCache.clear();
            tokenOrderBookRequests.clear();
            tokenOrderBookQueue.length = 0;
            tokenOrderBookQueued.clear();
            pendingOrderBookRefresh = false;
            if (orderBookRefreshTimer) {
                clearTimeout(orderBookRefreshTimer);
                orderBookRefreshTimer = null;
            }
            const data = await fetchMarkets(currentTagId);
            currentData = data;
            refreshView();
        } catch (err) {
            console.error(err);
            statusEl.textContent = "加载失败，请稍后重试";
        } finally {
            reloadBtn.disabled = false;
            outcomeToggleBtn.disabled = false;
            if (tagSelect) tagSelect.disabled = false;
            if (eventSelect) {
                const optionCount = eventSelect.options.length;
                eventSelect.disabled = optionCount <= 1;
            }
        }
    }

    function updateOutcomeButton() {
        outcomeToggleBtn.textContent = outcomeMode === "yesno" ? "筛选：YES/NO" : "筛选：Up/Down";
    }

    $("reload").addEventListener("click", () => load(currentTagId, {forceChartReload: true}));
    $("outcomeToggle").addEventListener("click", () => {
        outcomeMode = outcomeMode === "yesno" ? "updown" : "yesno";
        updateOutcomeButton();
        refreshView();
    });
    if (tagSelect) {
        tagSelect.addEventListener("change", (evt) => {
            const nextTag = Number.parseInt(evt.target.value, 10);
            load(Number.isNaN(nextTag) ? DEFAULT_TAG_ID : nextTag);
        });
    }
    if (eventSelect) {
        eventSelect.addEventListener("change", (evt) => {
            currentEventTicker = evt.target.value || null;
            refreshView();
        });
    }
    $("detailClose").addEventListener("click", hideDetail);
    $("detailPanel").addEventListener("click", (evt) => {
        if (evt.target === evt.currentTarget) hideDetail();
    });
    if (orderCloseBtn) {
        orderCloseBtn.addEventListener("click", closeOrderPanel);
    }
    if (orderPanel) {
        orderPanel.addEventListener("click", (evt) => {
            if (evt.target === evt.currentTarget) closeOrderPanel();
        });
    }
    if (orderForm) {
        orderForm.addEventListener("submit", async (evt) => {
            evt.preventDefault();
            if (!currentOrderContext) {
                setOrderStatus("请先选择需要下单的市场", true);
                return;
            }
            const price = parsePriceInput(orderBuyPriceInput.value);
            const size = Number(orderSizeInput.value);
            const takeProfitPrice = orderTakeProfitInput.value ? parsePriceInput(orderTakeProfitInput.value) : null;
            if (!Number.isFinite(price) || price <= 0) {
                setOrderStatus("请输入有效的买单价格（> 0%）", true);
                return;
            }
            if (price >= 1) {
                setOrderStatus("请输入低于 100% 的买单价格", true);
                return;
            }
            if (!Number.isFinite(size) || size <= 0) {
                setOrderStatus("请输入有效的买单数量", true);
                return;
            }
            if (orderTakeProfitInput.value && (!Number.isFinite(takeProfitPrice) || takeProfitPrice <= 0)) {
                setOrderStatus("请输入有效的止盈卖价（> 0%）", true);
                return;
            }
            if (Number.isFinite(takeProfitPrice) && takeProfitPrice >= 1) {
                setOrderStatus("止盈卖价需低于 100%", true);
                return;
            }
            const tokenInput = orderTokenGroup?.querySelector("input[name='orderTokenChoice']:checked");
            const tokenId = tokenInput?.value;
            if (!tokenId) {
                setOrderStatus("请选择 token", true);
                return;
            }

            const finalize = (success = false) => {
                orderSubmitBtn.disabled = false;
                if (success) {
                    const label = tokenInput?.dataset.label || "Token";
                    showOrderToast({
                        title: "买单成功",
                        message: `${label} · 价格 ${formatPrice(price)} · 数量 ${size}`,
                    });
                    closeOrderPanel();
                }
            };
            orderSubmitBtn.disabled = true;
            setOrderStatus("提交买单中…");
            try {
                await submitOrderRequest({price, size, side: "buy", tokenId});
                finalize(true);
            } catch (err) {
                setOrderStatus(err?.message || "下单失败", true);
                finalize(false);
            }
        });
    }
    window.addEventListener("resize", () => {
        if (lastChartDatasets.length) {
            drawChartWithView(lastChartDatasets);
        } else {
            drawTimeline();
        }
    });
    drawTimeline();
    setChartWindowInfo();
    updateOutcomeButton();
    load();
</script>
</body>
</html>
