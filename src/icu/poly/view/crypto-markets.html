<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>poly-market 加密市场</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root { --bg:#05070b; --card:#0f141c; --line:#1b2330; --muted:#94a3b8; --text:#f1f5f9; --accent:#38bdf8; }
        html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
        .wrap{max-width:1180px;margin:24px auto;padding:0 16px;}
        h1{font-size:20px;margin:0 0 12px;}
        .bar{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:16px;align-items:center;}
        button{background:var(--accent);border:none;color:#021018;padding:9px 16px;border-radius:999px;font-weight:600;cursor:pointer;}
        button:disabled{opacity:.5;cursor:not-allowed;}
        .status{color:var(--muted);font-size:13px;}
        select{background:var(--card);color:var(--text);border:1px solid var(--line);border-radius:8px;padding:8px 12px;font-weight:500;}
        table{width:100%;border-collapse:collapse;background:var(--card);border-radius:14px;overflow:hidden;border:1px solid var(--line);table-layout:auto;}
        thead{background:rgba(255,255,255,.02);position:sticky;top:0;}
        th,td{text-align:center;padding:6px 8px;border-bottom:1px solid var(--line);vertical-align:middle;}
        th{font-size:13px;color:var(--muted);white-space:nowrap;text-align:center;}
        tbody tr:hover{background:rgba(56,189,248,.08);}
        .muted{color:var(--muted);}
        .chip{display:inline-block;border:1px solid var(--line);padding:2px 10px;border-radius:999px;font-size:12px;color:var(--muted);margin-left:8px;}
        .scroll{overflow:auto;border-radius:14px;}
        code{padding:2px 4px;background:#1e293b;border-radius:4px;}
        .cell-value{display:inline-block;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
        th.col-question,td.col-question{min-width:220px;max-width:420px;}
        th.col-time,td.col-time{white-space:nowrap;}
        .detail-panel{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:20px;z-index:10;}
        .detail-panel.active{display:flex;}
        .detail-card{background:var(--card);border:1px solid var(--line);border-radius:12px;max-width:720px;width:100%;max-height:90vh;display:flex;flex-direction:column;}
        .detail-card header{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid var(--line);}
        .detail-card pre{margin:0;padding:16px;overflow:auto;white-space:pre-wrap;word-break:break-word;font-size:12px;background:#020812;border-bottom-left-radius:12px;border-bottom-right-radius:12px;}
        .detail-card button{margin:0;}
        .detail-trigger{background:none;border:1px solid var(--line);color:var(--text);padding:4px 10px;border-radius:8px;font-size:12px;}
        .detail-trigger:hover{border-color:var(--accent);color:var(--accent);}
        .chart-section{margin-top:24px;padding:18px;border:1px solid var(--line);border-radius:16px;background:var(--card);display:flex;flex-direction:column;gap:16px;}
        .chart-head{display:flex;flex-wrap:wrap;justify-content:space-between;gap:16px;}
        .chart-title{margin:0;font-size:18px;}
        .chart-status{margin:4px 0 0;font-size:13px;color:var(--muted);}
        .chart-range,.chart-window-info{margin:0;font-size:12px;color:var(--muted);}
        .chart-controls{display:flex;align-items:flex-end;gap:8px;}
        .chart-controls label{display:flex;flex-direction:column;font-size:13px;color:var(--muted);gap:4px;}
        .chart-controls select{min-width:120px;}
        .chart-visual{border:1px solid var(--line);border-radius:16px;padding:16px;background:rgba(255,255,255,0.01);display:flex;flex-direction:column;gap:16px;}
        .chart-main{display:flex;flex-direction:column;gap:12px;}
        .chart-main-canvas{position:relative;}
        #yesTokenChart{width:100%;height:1120px;border-radius:12px;border:1px solid var(--line);background:linear-gradient(180deg,#07101d,#02060c);display:block;}
        #chartEmpty{position:absolute;top:0;left:0;right:0;height:1000px;display:flex;align-items:center;justify-content:center;font-size:13px;color:var(--muted);pointer-events:none;}
        .chart-legend{display:flex;flex-wrap:wrap;gap:12px;font-size:12px;color:var(--muted);}
        .chart-legend-item{display:flex;align-items:center;gap:6px;}
        .chart-legend-dot{width:10px;height:10px;border-radius:50%;}
        .chart-token-panel{border:1px dashed var(--line);border-radius:14px;padding:12px;background:#060b14;display:flex;flex-direction:column;gap:10px;}
        .chart-token-head{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;font-size:13px;color:var(--muted);}
        .chart-token-actions{display:flex;gap:8px;}
        .chart-token-actions button{padding:6px 14px;font-size:12px;}
        .chart-token-list{display:flex;flex-wrap:wrap;gap:8px;}
        .chart-token-item{flex:1 1 220px;min-width:200px;border:1px solid var(--line);border-radius:12px;padding:8px 10px;background:#04070d;display:flex;align-items:center;gap:10px;}
        .chart-token-item label{flex:1;display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted);}
        .chart-token-item strong{font-size:14px;color:var(--text);}
        .chart-token-item input[type="checkbox"]{width:16px;height:16px;accent-color:var(--accent);}
        .chart-token-empty{font-size:13px;color:var(--muted);}
        .timeline-hint{font-size:12px;color:var(--muted);margin:4px 0 0;text-align:right;}
        @media (max-width:600px){
            .detail-card{max-width:none;height:90vh;}
        }
        @media (max-width:900px){
            table,thead,tbody,tr,td,th{display:block;}
            thead{display:none;}
            tr{border-bottom:1px solid var(--line);}
            td{display:flex;justify-content:space-between;gap:12px;align-items:center;}
            td::before{content:attr(data-th);font-weight:600;color:var(--muted);}
            .cell-value{flex:1;text-align:right;display:block;}
            th.col-question,td.col-question{width:auto;min-width:0;}
            th.col-time,td.col-time{width:auto;min-width:0;}
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Polymarket 加密市场列表 <span class="chip">末日市场</span></h1>
    <div class="bar">
        <button id="reload">刷新数据</button>
        <button id="outcomeToggle">筛选：YES/NO</button>
        <select id="tagSelect" aria-label="标签筛选"></select>
        <select id="eventSelect" aria-label="事件筛选"></select>
        <span id="status" class="status"></span>
    </div>
    <div class="scroll">
        <table>
            <thead>
            <tr id="cols"></tr>
            </thead>
            <tbody id="rows"></tbody>
        </table>
    </div>
    <section class="chart-section">
        <div class="chart-head">
            <div>
                <h2 class="chart-title">YES Token 价格曲线</h2>
                <p id="chartStatus" class="chart-status">等待市场列表加载…</p>
                <p id="chartRange" class="chart-range"></p>
                <p id="chartWindowInfo" class="chart-window-info">窗口：—</p>
            </div>
            <div class="chart-controls">
                <label>
                    时间粒度
                    <select id="chartInterval"></select>
                </label>
            </div>
        </div>
        <div class="chart-token-panel">
            <div class="chart-token-head">
                <span>曲线列表（自动来自当前市场）</span>
                <div class="chart-token-actions">
                    <button type="button" id="chartSelectAll">全选</button>
                    <button type="button" id="chartClearAll">全不选</button>
                </div>
            </div>
            <div id="chartTokenList" class="chart-token-list"></div>
        </div>
        <div class="chart-visual">
            <div class="chart-main">
                <div class="chart-main-canvas">
                    <canvas id="yesTokenChart" width="2000" height="1120" role="img" aria-label="市场 YES token 价格曲线"></canvas>
                    <div id="chartEmpty">暂无可绘制的 YES token</div>
                </div>
                <span class="timeline-hint">拖动底部选择框即可缩放/移动时间区间</span>
            </div>
        </div>
        <div id="chartLegend" class="chart-legend"></div>
    </section>
</div>

<div id="detailPanel" class="detail-panel">
    <div class="detail-card">
        <header>
            <span id="detailTitle"></span>
            <button id="detailClose">关闭</button>
        </header>
        <pre id="detailJson"></pre>
    </div>
</div>

<script>
    const API = "/api/crypto-markets";
    const PRICE_HISTORY_API = "/api/price-history";
    const CHART_INTERVALS = [
        {value: "1h", label: "1 小时"},
        {value: "6h", label: "6 小时"},
        {value: "1d", label: "1 天"},
        {value: "1w", label: "1 周"},
        {value: "max", label: "Max"},
    ];
    const CHART_ZOOM_MIN = 0.05;
    const CHART_ZOOM_MAX = 1;
    const TIMELINE_HEIGHT = 100;
    const TIMELINE_PADDING = 24;
    const MAIN_CHART_HEIGHT = 1000;
    const TIMELINE_GAP = 20;
    const TOTAL_CANVAS_HEIGHT = MAIN_CHART_HEIGHT + TIMELINE_GAP + TIMELINE_HEIGHT;
    const CHART_COLORS = ["#22d3ee", "#fb7185", "#a78bfa", "#34d399", "#f472b6", "#f97316", "#38bdf8", "#facc15"];
    const fields = [
        { key: "question", label: "问题", className: "col-question" },
        { key: "outcomes", label: "结果" },
        { key: "endDate", label: "结束时间", className: "col-time" },
        { key: "yesBestAsk", label: "YES最优卖价" },
        { key: "noBestAsk", label: "NO最优卖价" },
        { key: "volume24hr", label: "24h 交易量", compact: true },
        { key: "liquidityNum", label: "流动性", compact: true },
    ];
    const compactNumberKeys = new Set(fields.filter(f => f.compact).map(f => f.key));
    const priceMultiplierKeys = new Set(["lastTradePrice"]);
    const PRICE_MULTIPLIER = 100;
    const TAG_OPTIONS = [
        { id: 21, label: "Crypto" },
        { id: 235, label: "Bitcoin" },
        { id: 39, label: "Ethereum" },
    ];
    const DEFAULT_TAG_ID = 235;
    let outcomeMode = "yesno";
    let currentData = [];
    let currentTagId = DEFAULT_TAG_ID;
    let currentEventTicker = null;
    let lastRenderedMarkets = [];
    let chartInterval = "1d";
    let lastChartDatasets = [];
    let chartRequestId = 0;
    let chartAbortController = null;
    let chartTokens = [];
    let chartTimeBounds = null;
    let chartViewSpan = 1;
    let chartViewOffsetRatio = 0;
    let chartCurrentWindow = null;
    let timelineDragState = null;
    const selectedChartTokenIds = new Set();
    const chartHistoryCache = new Map();
    const detailKeys = [
        "id",
        "question",
        "conditionId",
        "slug",
        "endDate",
        "startDate",
        "outcomes",
        "outcomePrices",
        "createdAt",
        "questionID",
        "volumeNum",
        "liquidityNum",
        "endDateIso",
        "startDateIso",
        "volume24hr",
        "clobTokenIds",
        "events",
        "lastTradePrice",
        "bestBid",
        "bestAsk",
        "eventStartTime",
    ];
    const eventDetailKeys = ["id", "ticker", "slug", "title", "startDate", "endDate"];

    const $ = (id) => document.getElementById(id);
    const cols = $("cols");
    const statusEl = $("status");
    const reloadBtn = $("reload");
    const outcomeToggleBtn = $("outcomeToggle");
    const tagSelect = $("tagSelect");
    const eventSelect = $("eventSelect");
    const chartCanvas = $("yesTokenChart");
    const chartEmpty = $("chartEmpty");
    const chartLegend = $("chartLegend");
    const chartStatusEl = $("chartStatus");
    const chartRangeEl = $("chartRange");
    const chartIntervalSelect = $("chartInterval");
    const chartWindowInfo = $("chartWindowInfo");
    const chartTokenList = $("chartTokenList");
    const chartSelectAllBtn = $("chartSelectAll");
    const chartClearAllBtn = $("chartClearAll");
    fields.forEach(f => {
        const th = document.createElement("th");
        th.textContent = f.label;
        if (f.className) th.classList.add(f.className);
        cols.appendChild(th);
    });
    const detailHead = document.createElement("th");
    detailHead.textContent = "详细";
    cols.appendChild(detailHead);

    const dateFieldRegex = /(date|time)$/i;
    const compactFormatter = new Intl.NumberFormat("en", { notation: "compact", maximumFractionDigits: 1 });
    const chartDateFormatter = new Intl.DateTimeFormat("zh-CN", {
        timeZone: "Asia/Shanghai",
        hour12: false,
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
    });
    const PRICE_GRID_STEPS = 20;
    const outcomeSetMap = {
        yesno: new Set(["yes", "no"]),
        updown: new Set(["up", "down"]),
    };

    function parseJsonArray(value) {
        if (Array.isArray(value)) return value;
        if (typeof value === "string") {
            try {
                const parsed = JSON.parse(value);
                if (Array.isArray(parsed)) return parsed;
            } catch (_) {
                // ignore malformed json
            }
        }
        return null;
    }

    function parseOutcomes(value) {
        const parsed = parseJsonArray(value);
        return Array.isArray(parsed) ? parsed : null;
    }

    function parseClobTokenIds(value) {
        const parsed = parseJsonArray(value);
        return Array.isArray(parsed) ? parsed : null;
    }

    function parseOutcomePrices(value) {
        const parsed = parseJsonArray(value);
        return Array.isArray(parsed) ? parsed : null;
    }

    function getYesTokenId(item) {
        const tokens = parseClobTokenIds(item?.clobTokenIds);
        if (!tokens || !tokens.length) return null;
        const tokenId = tokens[0];
        if (tokenId === undefined || tokenId === null) return null;
        return String(tokenId);
    }

    function shorten(value) {
        if (!value) return "";
        const str = String(value);
        return str.length <= 16 ? str : `${str.slice(0, 6)}…${str.slice(-4)}`;
    }

    function buildFallbackLabel(context, tokenId, preferredLabel) {
        if (preferredLabel) return preferredLabel;
        const ticker = context?.ticker || null;
        if (ticker) return ticker;
        if (typeof context?.question === "string" && context.question.trim()) return context.question.trim();
        return shorten(tokenId);
    }

    function buildTickerDifferenceLabels(tickers) {
        const uniqueTickers = [...new Set(tickers.filter(ticker => typeof ticker === "string" && ticker.trim().length))];
        if (uniqueTickers.length <= 1) return new Map();
        const normalized = uniqueTickers.map(ticker => ticker.trim());
        const comparable = normalized.map(ticker => ticker.toLowerCase());
        const prefixLen = findCommonPrefixLength(comparable);
        const suffixLen = findCommonSuffixLength(comparable);
        const result = new Map();
        normalized.forEach((ticker, idx) => {
            const original = uniqueTickers[idx];
            let slice = original.slice(prefixLen);
            if (suffixLen) {
                slice = slice.slice(0, Math.max(0, slice.length - suffixLen));
            }
            slice = slice.replace(/[-_]+/g, " ").trim();
            if (!slice) {
                slice = original.replace(/[-_]+/g, " ").trim();
            }
            result.set(original, slice);
        });
        return result;
    }

    function findCommonPrefixLength(list) {
        if (!list.length) return 0;
        let prefix = list[0];
        for (let i = 1; i < list.length; i++) {
            const current = list[i];
            let j = 0;
            while (j < prefix.length && j < current.length && prefix[j] === current[j]) {
                j++;
            }
            prefix = prefix.slice(0, j);
            if (!prefix) break;
        }
        return prefix.length;
    }

    function findCommonSuffixLength(list) {
        if (!list.length) return 0;
        let suffix = list[0];
        for (let i = 1; i < list.length; i++) {
            const current = list[i];
            let j = 0;
            while (
                j < suffix.length &&
                j < current.length &&
                suffix[suffix.length - 1 - j] === current[current.length - 1 - j]
            ) {
                j++;
            }
            suffix = suffix.slice(suffix.length - j);
            if (!suffix) break;
        }
        return suffix.length;
    }

    function extractEventTicker(item) {
        if (!item || !Array.isArray(item.events) || !item.events.length) return null;
        const event = item.events[0];
        if (!event || typeof event.ticker !== "string") return null;
        const trimmed = event.ticker.trim();
        return trimmed.length ? trimmed : null;
    }

    function buildEventOptions(list) {
        const map = new Map();
        list.forEach(item => {
            const ticker = extractEventTicker(item);
            if (!ticker || map.has(ticker)) return;
            const event = Array.isArray(item.events) ? item.events[0] : null;
            map.set(ticker, {
                ticker,
                label: event?.title || event?.slug || ticker,
            });
        });
        return [...map.values()].sort((a, b) => a.ticker.localeCompare(b.ticker));
    }

    function updateEventFilterOptions(list) {
        if (!eventSelect) return;
        const options = buildEventOptions(list);
        eventSelect.innerHTML = "";
        if (!options.length) {
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "暂无事件";
            eventSelect.appendChild(opt);
            eventSelect.disabled = true;
            currentEventTicker = null;
            return;
        }
        options.forEach(info => {
            const opt = document.createElement("option");
            opt.value = info.ticker;
            const labelText = info.label === info.ticker ? info.ticker : `${info.ticker} · ${info.label}`;
            opt.textContent = labelText;
            eventSelect.appendChild(opt);
        });
        if (!currentEventTicker || !options.some(opt => opt.ticker === currentEventTicker)) {
            currentEventTicker = options[0].ticker;
        }
        eventSelect.value = currentEventTicker;
        eventSelect.disabled = options.length <= 1;
    }

    function getOutcomeCategory(value) {
        const parsed = parseOutcomes(value);
        if (!parsed || parsed.length !== 2) return null;
        const normalized = parsed.map(v => String(v).trim().toLowerCase());
        const unique = new Set(normalized);
        if (unique.size !== 2) return null;
        const entries = [...unique];
        if (entries.every(val => outcomeSetMap.yesno.has(val))) return "yesno";
        if (entries.every(val => outcomeSetMap.updown.has(val))) return "updown";
        return null;
    }

    function filterByEvent(list) {
        if (!currentEventTicker) return list;
        return list.filter(item => extractEventTicker(item) === currentEventTicker);
    }

    function filterByOutcomeMode(list) {
        return list.filter(item => getOutcomeCategory(item.outcomes) === outcomeMode);
    }

    function normalizeSortDate(value) {
        const time = new Date(value).getTime();
        return Number.isFinite(time) ? time : Number.POSITIVE_INFINITY;
    }

    function normalizeSortNumber(value) {
        if (typeof value === "number") {
            return Number.isFinite(value) ? value : Number.POSITIVE_INFINITY;
        }
        const num = Number(value);
        return Number.isFinite(num) ? num : Number.POSITIVE_INFINITY;
    }

    function sortMarkets(list) {
        return [...list].sort((a, b) => {
            const endA = normalizeSortDate(a.endDate);
            const endB = normalizeSortDate(b.endDate);
            if (endA !== endB) return endA - endB;
            const askA = normalizeSortNumber(a.bestAsk);
            const askB = normalizeSortNumber(b.bestAsk);
            return askA - askB;
        });
    }

    function formatDateToCST(value) {
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return value;
        return new Intl.DateTimeFormat("zh-CN", {
            timeZone: "Asia/Shanghai",
            dateStyle: "short",
            timeStyle: "short",
        }).format(date);
    }

    function formatValue(value, field) {
        const key = typeof field === "string" ? field : field?.key;
        if (value === null || value === undefined || value === "") return "—";
        let displayValue = value;
        if (key && priceMultiplierKeys.has(key)) {
            const numeric = typeof displayValue === "number" ? displayValue : Number(displayValue);
            if (Number.isFinite(numeric)) {
                displayValue = Math.round(numeric * PRICE_MULTIPLIER);
            }
        }
        if (key && dateFieldRegex.test(key) && typeof displayValue === "string") {
            return formatDateToCST(displayValue);
        }
        if (key === "outcomes") {
            const parsed = parseOutcomes(displayValue);
            if (Array.isArray(parsed) && parsed.length === 2) {
                return outcomeMode === "yesno" ? "YES / NO" : "UP / DOWN";
            }
            if (Array.isArray(parsed)) return parsed.join(" / ");
            return displayValue;
        }
        if (Array.isArray(displayValue)) return displayValue.join(", ");
        if (typeof displayValue === "number") {
            if (key && compactNumberKeys.has(key)) {
                return compactFormatter.format(displayValue);
            }
            return Math.abs(displayValue) >= 1000 ? displayValue.toLocaleString() : displayValue;
        }
        if (typeof displayValue === "string") {
            if (key && compactNumberKeys.has(key)) {
                const num = Number(displayValue);
                if (!Number.isNaN(num)) {
                    return compactFormatter.format(num);
                }
            }
            try {
                const parsed = JSON.parse(displayValue);
                if (Array.isArray(parsed)) return parsed.join(", ");
            } catch (_) {
                // keep original string
            }
        }
        return displayValue;
    }

    function collectYesTokens(list) {
        const map = new Map();
        list.forEach(item => {
            const tokenId = getYesTokenId(item);
            if (!tokenId || map.has(tokenId)) return;
            map.set(tokenId, {
                tokenId,
                ticker: extractEventTicker(item),
                question: typeof item.question === "string" ? item.question.trim() : "",
            });
        });
        const tokens = [...map.values()];
        const tickerLabels = buildTickerDifferenceLabels(tokens.map(token => token.ticker));
        return tokens.map(token => ({
            tokenId: token.tokenId,
            ticker: token.ticker,
            label: buildFallbackLabel(token, token.tokenId, tickerLabels.get(token.ticker)),
            question: token.question,
        }));
    }

    function enrichMarketStats(list) {
        return list.map(item => {
            const yesAsk = extractOutcomePrice(item, 0);
            const noAsk = extractOutcomePrice(item, 1);
            return {...item, yesBestAsk: yesAsk, noBestAsk: noAsk};
        });
    }

    function extractOutcomePrice(item, index) {
        const prices = parseOutcomePrices(item?.outcomePrices);
        if (!prices || prices.length <= index) return null;
        const value = Number(prices[index]);
        if (!Number.isFinite(value)) return null;
        return Math.round(value * 100);
    }

    function buildHistoryKey(tokenId, interval) {
        return `${tokenId}::${interval}`;
    }

    function setHistoryPoints(tokenId, interval, history) {
        chartHistoryCache.set(buildHistoryKey(tokenId, interval), buildPoints(history));
    }

    function getHistoryPoints(tokenId, interval) {
        return chartHistoryCache.get(buildHistoryKey(tokenId, interval)) || null;
    }

    function hasHistory(tokenId, interval) {
        return chartHistoryCache.has(buildHistoryKey(tokenId, interval));
    }

    function pruneHistoryCache(validTokenIds) {
        const validSet = new Set(validTokenIds);
        for (const key of chartHistoryCache.keys()) {
            const [tokenId] = key.split("::");
            if (!validSet.has(tokenId)) {
                chartHistoryCache.delete(key);
            }
        }
    }

    function syncChartTokens(tokens) {
        chartTokens = tokens;
        const validIds = new Set(tokens.map(token => token.tokenId));
        pruneHistoryCache(validIds);
        [...selectedChartTokenIds].forEach(id => {
            if (!validIds.has(id)) selectedChartTokenIds.delete(id);
        });
        if (!selectedChartTokenIds.size) {
            tokens.forEach(token => selectedChartTokenIds.add(token.tokenId));
        }
        renderChartTokenList();
    }

    function renderChartTokenList() {
        if (!chartTokenList) return;
        chartTokenList.innerHTML = "";
        if (!chartTokens.length) {
            const empty = document.createElement("div");
            empty.className = "chart-token-empty";
            empty.textContent = "暂无 YES token";
            chartTokenList.appendChild(empty);
            return;
        }
        chartTokens.forEach(token => {
            const item = document.createElement("div");
            item.className = "chart-token-item";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = selectedChartTokenIds.has(token.tokenId);
            checkbox.addEventListener("change", () => {
                handleTokenSelectionChange(token.tokenId, checkbox.checked);
            });

            const label = document.createElement("label");
            const title = document.createElement("strong");
            title.textContent = token.label;
            const subtitle = document.createElement("span");
            subtitle.textContent = token.question || token.ticker || token.tokenId;
            subtitle.title = token.question || token.ticker || token.tokenId;
            label.appendChild(title);
            label.appendChild(subtitle);

            item.appendChild(checkbox);
            item.appendChild(label);
        chartTokenList.appendChild(item);
    });
}

function handleTokenSelectionChange(tokenId, checked) {
        if (checked) {
            selectedChartTokenIds.add(tokenId);
        } else {
            selectedChartTokenIds.delete(tokenId);
        }
        renderChartTokenList();
        renderChartFromCache();
    }

    function buildDatasetsFromCache() {
        const selectedTokens = chartTokens.filter(token => selectedChartTokenIds.has(token.tokenId));
        const datasets = selectedTokens.map(token => {
            const points = getHistoryPoints(token.tokenId, chartInterval);
            if (!points || !points.length) return null;
            return {
                label: token.label,
                tokenId: token.tokenId,
                color: getChartColorForToken(token.tokenId),
                points,
            };
        }).filter(Boolean);
        return {datasets, totalCount: chartTokens.length, selectedCount: selectedTokens.length};
    }

    function getChartColorForToken(tokenId) {
        const index = chartTokens.findIndex(token => token.tokenId === tokenId);
        return getChartColor(index >= 0 ? index : chartTokens.length);
    }

    function renderChartFromCache({failureCount = 0} = {}) {
        const {datasets, totalCount, selectedCount} = buildDatasetsFromCache();
        let message;
        if (!totalCount) {
            message = "当前筛选下没有 YES token";
        } else if (!selectedCount) {
            message = `共 ${totalCount} 个 YES token，请至少选择 1 个`;
        } else if (!datasets.length) {
            message = `已选 ${selectedCount} 个，但暂无价格数据`;
        } else {
            if (selectedCount === datasets.length) {
                message = `已选 ${datasets.length}/${totalCount} 条曲线`;
            } else {
                message = `已选 ${selectedCount}/${totalCount} 个，绘制 ${datasets.length} 条`;
            }
        }
        if (failureCount) {
            message = `${message}，${failureCount} 个加载失败`;
        }
        setChartStatus(message);
        renderChart(datasets);
        renderChartLegend(datasets);
    }

    async function refreshYesTokenChart(markets = lastRenderedMarkets) {
        if (!chartCanvas || !chartStatusEl) return;
        lastRenderedMarkets = markets;
        const tokens = collectYesTokens(markets);
        syncChartTokens(tokens);
        if (!tokens.length) {
            setChartStatus("当前筛选下没有 YES token");
            renderChart([]);
            renderChartLegend([]);
            return;
        }
        if (chartAbortController) {
            chartAbortController.abort();
        }
        chartAbortController = new AbortController();
        const {signal} = chartAbortController;
        const requestId = ++chartRequestId;
        setChartStatus(`共 ${tokens.length} 个 YES token，加载价格数据…`);
        try {
            const {failureCount} = await loadHistoriesForTokens(tokens, chartInterval, signal);
            if (requestId !== chartRequestId) return;
            renderChartFromCache({failureCount});
        } catch (err) {
            if (err.name === "AbortError") return;
            console.error(err);
            setChartStatus("加载价格曲线失败");
            renderChart([]);
            renderChartLegend([]);
        }
    }

    async function loadHistoriesForTokens(tokens, interval, signal) {
        const pending = tokens.filter(token => !hasHistory(token.tokenId, interval));
        if (!pending.length) return {failureCount: 0};
        const tasks = pending.map(token =>
            fetchYesTokenHistory(token.tokenId, interval, signal)
                .then(history => ({token, history}))
                .catch(error => {
                    if (error?.name === "AbortError") throw error;
                    return {token, error, failed: true};
                })
        );
        const results = await Promise.all(tasks);
        let failureCount = 0;
        results.forEach(result => {
            if (result.failed) {
                failureCount++;
                console.error(`加载 YES token ${result.token.tokenId} 价格失败:`, result.error?.message || result.error);
                return;
            }
            setHistoryPoints(result.token.tokenId, interval, result.history);
        });
        return {failureCount};
    }

    async function fetchYesTokenHistory(tokenId, interval, signal) {
        const params = new URLSearchParams();
        params.append("market", tokenId);
        params.append("interval", interval);
        const res = await fetch(`${PRICE_HISTORY_API}?${params.toString()}`, {signal});
        if (!res.ok) {
            const payload = await safeJson(res);
            throw new Error(payload?.message || "请求失败");
        }
        const data = await res.json();
        return Array.isArray(data?.history) ? data.history : [];
    }

    function renderChartLegend(datasets) {
        if (!chartLegend) return;
        if (!datasets.length) {
            chartLegend.innerHTML = "";
            return;
        }
        chartLegend.innerHTML = datasets.map(({label, color, tokenId}) => `
            <div class="chart-legend-item">
                <span class="chart-legend-dot" style="background:${color}"></span>
                <span title="${tokenId}">${label}</span>
            </div>
        `).join("");
    }

    function setChartStatus(message) {
        if (chartStatusEl) chartStatusEl.textContent = message || "";
    }

    function setChartRangeLabel(start, end) {
        if (!chartRangeEl) return;
        if (!Number.isFinite(start) || !Number.isFinite(end)) {
            chartRangeEl.textContent = "";
            return;
        }
        chartRangeEl.textContent = `${formatChartTimestamp(start)} - ${formatChartTimestamp(end)}`;
    }

    function setChartWindowInfo(start, end) {
        if (!chartWindowInfo) return;
        if (!Number.isFinite(start) || !Number.isFinite(end)) {
            chartWindowInfo.textContent = "窗口：—";
            return;
        }
        const duration = formatDuration(end - start);
        const isFullRange = chartViewSpan >= 0.999 || (chartTimeBounds && chartTimeBounds.max <= chartTimeBounds.min);
        const label = isFullRange ? `窗口：全区间（${duration}）` : `窗口：${duration}`;
        chartWindowInfo.textContent = label;
    }

    function formatChartTimestamp(value) {
        if (!Number.isFinite(value)) return "";
        return chartDateFormatter.format(new Date(value));
    }

    function formatTimelineLabel(value) {
        if (!Number.isFinite(value)) return "";
        return new Intl.DateTimeFormat("zh-CN", {
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
        }).format(new Date(value));
    }

    function formatDuration(ms) {
        if (!Number.isFinite(ms) || ms <= 0) return "少于 1 分钟";
        const totalMinutes = Math.floor(ms / 60000);
        const days = Math.floor(totalMinutes / (60 * 24));
        const hours = Math.floor((totalMinutes % (60 * 24)) / 60);
        const minutes = totalMinutes % 60;
        const parts = [];
        if (days) parts.push(`${days}天`);
        if (hours) parts.push(`${hours}小时`);
        if (minutes && parts.length < 2) parts.push(`${minutes}分钟`);
        return parts.length ? parts.join("") : "少于 1 分钟";
    }

    function clampZoomSpan(value) {
        if (!Number.isFinite(value)) return CHART_ZOOM_MAX;
        return Math.min(CHART_ZOOM_MAX, Math.max(CHART_ZOOM_MIN, value));
    }


    function renderChart(datasets) {
        if (!chartCanvas) return;
        const usable = datasets.filter(dataset => dataset.points && dataset.points.length);
        if (!usable.length) {
            chartCanvas.style.display = "none";
            if (chartEmpty) chartEmpty.style.display = "flex";
            lastChartDatasets = [];
            chartTimeBounds = null;
            chartCurrentWindow = null;
            timelineDragState = null;
            setChartRangeLabel();
            setChartWindowInfo();
            drawTimeline();
            return;
        }
        lastChartDatasets = usable;
        chartTimeBounds = computeTimeBounds(usable);
        chartCanvas.style.display = "block";
        if (chartEmpty) chartEmpty.style.display = "none";
        drawChartWithView(usable);
    }

    function drawChartWithView(datasets) {
        const {series, viewWindow} = applyViewWindow(datasets);
        const hasPoints = series.some(dataset => dataset.points && dataset.points.length);
        if (!hasPoints) {
            chartCanvas.style.display = "none";
            if (chartEmpty) chartEmpty.style.display = "flex";
            setChartRangeLabel(viewWindow?.start, viewWindow?.end);
            setChartWindowInfo(viewWindow?.start, viewWindow?.end);
            return;
        }
        chartCanvas.style.display = "block";
        if (chartEmpty) chartEmpty.style.display = "none";
        drawChart(series);
        drawTimeline();
        const start = viewWindow?.start ?? chartTimeBounds?.min;
        const end = viewWindow?.end ?? chartTimeBounds?.max;
        setChartRangeLabel(start, end);
        setChartWindowInfo(start, end);
    }

    function computeTimeBounds(datasets) {
        const times = datasets.flatMap(set => (set.points || []).map(point => point.time));
        if (!times.length) return null;
        let min = times[0];
        let max = times[0];
        times.forEach(time => {
            if (time < min) min = time;
            if (time > max) max = time;
        });
        return {min, max};
    }

    function getViewWindowBounds() {
        if (!chartTimeBounds) return null;
        const {min, max} = chartTimeBounds;
        const totalRange = Math.max(1, max - min);
        if (chartViewSpan >= 0.999) {
            return {start: min, end: max};
        }
        const availableFraction = Math.max(0, 1 - chartViewSpan);
        const offsetFraction = availableFraction <= 0 ? 0 : chartViewOffsetRatio * availableFraction;
        const windowSpan = Math.max(1, totalRange * chartViewSpan);
        const maxStart = Math.max(min, max - windowSpan);
        const rawStart = min + totalRange * offsetFraction;
        const clampedStart = Math.min(Math.max(min, rawStart), maxStart);
        const windowEnd = Math.min(max, clampedStart + windowSpan);
        return {start: clampedStart, end: windowEnd};
    }

    function applyViewWindow(datasets) {
        const bounds = getViewWindowBounds();
        if (!bounds) {
            chartCurrentWindow = null;
            return {series: datasets, window: null};
        }
        chartCurrentWindow = bounds;
        if (chartViewSpan >= 0.999) {
            return {series: datasets, window: bounds};
        }
        const clipped = datasets.map(dataset => ({
            ...dataset,
            points: clipPointsToWindow(dataset.points, bounds.start, bounds.end),
        }));
        return {series: clipped, window: bounds};
    }

    function clipPointsToWindow(points = [], start, end) {
        if (!points.length) return [];
        const result = [];
        let lastBefore = null;
        let firstAfter = null;
        let addedBefore = false;
        for (const point of points) {
            if (point.time < start) {
                lastBefore = point;
                continue;
            }
            if (!addedBefore && lastBefore) {
                result.push(lastBefore);
                addedBefore = true;
            }
            if (point.time > end) {
                firstAfter = point;
                break;
            }
            result.push(point);
        }
        if (!result.length && lastBefore) {
            result.push(lastBefore);
        }
        if (firstAfter) {
            result.push(firstAfter);
        } else if (!result.length) {
            result.push(points[points.length - 1]);
        }
        return result;
    }

    function redrawChartWithCurrentView() {
        if (!lastChartDatasets.length) {
            drawTimeline();
            return;
        }
        drawChartWithView(lastChartDatasets);
    }

    function drawChart(series) {
        if (!chartCanvas) return;
        const ctx = chartCanvas.getContext("2d");
        if (!ctx) return;
        const ratio = window.devicePixelRatio || 1;
        const width = chartCanvas.clientWidth || chartCanvas.width;
        chartCanvas.width = width * ratio;
        chartCanvas.height = TOTAL_CANVAS_HEIGHT * ratio;
        chartCanvas.style.width = `${width}px`;
        chartCanvas.style.height = `${TOTAL_CANVAS_HEIGHT}px`;
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        ctx.clearRect(0, 0, width, TOTAL_CANVAS_HEIGHT);

        const padding = {top: 18, right: 56, bottom: 28, left: 56};
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = MAIN_CHART_HEIGHT - padding.top - padding.bottom;

        const times = Array.from(new Set(series.flatMap(set => set.points.map(p => p.time)))).sort((a, b) => a - b);
        if (!times.length) return;
        const timeMin = times[0];
        const timeMax = times[times.length - 1] || (timeMin + 1);
        const timeRange = timeMax - timeMin || 1;
        const priceMin = 0;
        const priceMax = 1;
        const priceRange = priceMax - priceMin || 1;

        const clampPrice = price => Math.min(priceMax, Math.max(priceMin, price));
        const xFor = time => padding.left + ((time - timeMin) / timeRange) * chartWidth;
        const yFor = price => padding.top + chartHeight * (1 - (clampPrice(price) - priceMin) / priceRange);

        drawGrid(ctx, padding, chartWidth, chartHeight, priceMin, priceMax);
        series.forEach(set => drawLineSeries(ctx, set, xFor, yFor, padding, chartHeight));
    }

    function drawTimeline() {
        if (!chartCanvas) return;
        const ctx = chartCanvas.getContext("2d");
        if (!ctx) return;
        const width = chartCanvas.clientWidth || chartCanvas.width;
        const metrics = getTimelineMetrics(width);
        drawTimelineBackground(ctx, metrics);

        if (!chartTimeBounds) {
            drawTimelineEmpty(ctx, metrics);
            return;
        }

        const viewWindow = getViewWindowBounds();
        if (viewWindow) {
            const range = Math.max(1, chartTimeBounds.max - chartTimeBounds.min);
            const startRatio = (viewWindow.start - chartTimeBounds.min) / range;
            const endRatio = (viewWindow.end - chartTimeBounds.min) / range;
            drawTimelineSelection(ctx, metrics, startRatio, endRatio);
        }
        drawTimelineTicks(ctx, metrics, chartTimeBounds.min, chartTimeBounds.max);
    }

    function drawTimelineBackground(ctx, metrics) {
        const top = metrics.top;
        const gradient = ctx.createLinearGradient(0, top, 0, top + metrics.height);
        gradient.addColorStop(0, "rgba(56,189,248,0.25)");
        gradient.addColorStop(1, "rgba(15,20,28,0.8)");
        ctx.fillStyle = gradient;
        ctx.fillRect(metrics.padding, top, metrics.usableWidth, metrics.height);

        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 1;
        ctx.strokeRect(metrics.padding, top, metrics.usableWidth, metrics.height);
    }

    function drawTimelineEmpty(ctx, metrics) {
        drawTimelineBackground(ctx, metrics);
        ctx.fillStyle = "#94a3b8";
        ctx.font = "12px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("等待数据加载…", metrics.padding + metrics.usableWidth / 2, metrics.top + metrics.height / 2);
    }

    function getTimelineMetrics(widthOverride) {
        const width = widthOverride ?? (chartCanvas?.clientWidth || chartCanvas?.width || 800);
        const padding = TIMELINE_PADDING;
        const usableWidth = Math.max(1, width - padding * 2);
        const top = MAIN_CHART_HEIGHT + TIMELINE_GAP;
        return {width, height: TIMELINE_HEIGHT, padding, usableWidth, top};
    }

    function drawTimelineSelection(ctx, metrics, startRatio, endRatio) {
        const startClamped = Math.max(0, Math.min(1, startRatio));
        const endClamped = Math.max(0, Math.min(1, endRatio));
        const rawStartX = ratioToTimelineX(startClamped, metrics);
        const rawEndX = ratioToTimelineX(endClamped, metrics);
        const left = Math.min(rawStartX, rawEndX);
        const right = Math.max(rawStartX, rawEndX);
        const selectionWidth = Math.max(6, right - left);
        ctx.fillStyle = "rgba(56,189,248,0.12)";
        ctx.fillRect(left, metrics.top + 4, selectionWidth, metrics.height - 8);
        ctx.strokeStyle = "#38bdf8";
        ctx.lineWidth = 2;
        ctx.strokeRect(left, metrics.top + 4, selectionWidth, metrics.height - 8);
        [rawStartX, rawEndX].forEach(x => {
            ctx.fillStyle = "#38bdf8";
            ctx.fillRect(x - 4, metrics.top + 4, 8, metrics.height - 8);
        });
    }

    function drawTimelineTicks(ctx, metrics, minTime, maxTime) {
        if (!Number.isFinite(minTime) || !Number.isFinite(maxTime) || maxTime <= minTime) return;
        const {primaryInterval, secondaryInterval} = chooseTimelineIntervals(minTime, maxTime, metrics.usableWidth);
        drawTimelineTickLayer(ctx, metrics, minTime, maxTime, primaryInterval, true);
        if (secondaryInterval) {
            drawTimelineTickLayer(ctx, metrics, minTime, maxTime, secondaryInterval, false);
        }
    }

    function drawTimelineTickLayer(ctx, metrics, minTime, maxTime, intervalMs, emphasize) {
        if (!intervalMs || intervalMs <= 0) return;
        const range = maxTime - minTime;
        const startTime = Math.ceil(minTime / intervalMs) * intervalMs;
        ctx.font = emphasize ? "11px system-ui" : "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        for (let time = startTime; time <= maxTime; time += intervalMs) {
            const ratio = (time - minTime) / range;
            const x = metrics.padding + ratio * metrics.usableWidth;
            ctx.fillStyle = emphasize ? "rgba(255,255,255,0.45)" : "rgba(255,255,255,0.25)";
            const tickHeight = emphasize ? 22 : 14;
            ctx.fillRect(x - 0.5, metrics.top + metrics.height - 4 - tickHeight, 1, tickHeight);
            if (emphasize) {
                ctx.fillStyle = "#cbd5f5";
                ctx.fillText(formatTimelineLabel(time), x, metrics.top + metrics.height - 6);
            }
        }
    }

    function chooseTimelineIntervals(minTime, maxTime, width) {
        const range = maxTime - minTime;
        if (range <= 0) return {primaryInterval: 0, secondaryInterval: 0};
        const targetTickCount = Math.max(10, Math.min(16, Math.floor(width / 100)));
        let intervalMs = snapInterval(range / targetTickCount);
        let tickCount = Math.floor(range / intervalMs);
        while (tickCount < 10 && intervalMs > SNAP_INTERVALS[0]) {
            const next = Math.max(SNAP_INTERVALS[0], intervalMs / 2);
            if (next === intervalMs) break;
            intervalMs = next;
            tickCount = Math.floor(range / intervalMs);
        }
        const secondary = intervalMs >= 2 * SNAP_INTERVALS[0] ? Math.max(SNAP_INTERVALS[0], intervalMs / 2) : 0;
        return {primaryInterval: intervalMs, secondaryInterval: secondary};
    }

    const SNAP_INTERVALS = [
        60 * 1000,
        5 * 60 * 1000,
        10 * 60 * 1000,
        15 * 60 * 1000,
        30 * 60 * 1000,
        60 * 60 * 1000,
        2 * 60 * 60 * 1000,
        6 * 60 * 60 * 1000,
        12 * 60 * 60 * 1000,
        24 * 60 * 60 * 1000,
        3 * 24 * 60 * 60 * 1000,
        7 * 24 * 60 * 60 * 1000,
        14 * 24 * 60 * 60 * 1000,
        30 * 24 * 60 * 60 * 1000,
    ];

    function snapInterval(value) {
        for (const option of SNAP_INTERVALS) {
            if (value <= option) return option;
        }
        return SNAP_INTERVALS[SNAP_INTERVALS.length - 1];
    }

    function getTimelinePosition(event, metrics = getTimelineMetrics()) {
        if (!chartCanvas) return {x: 0, y: 0};
        const rect = chartCanvas.getBoundingClientRect();
        return {
            x: Math.max(0, Math.min(metrics.width, event.clientX - rect.left)),
            y: event.clientY - rect.top,
        };
    }

    function ratioToTimelineX(ratio, metrics) {
        return metrics.padding + Math.max(0, Math.min(1, ratio)) * metrics.usableWidth;
    }

    function positionToTimelineRatio(x, metrics) {
        return Math.max(0, Math.min(1, (x - metrics.padding) / metrics.usableWidth));
    }

    function getWindowRatios() {
        if (!chartTimeBounds) return {start: 0, end: 1};
        const bounds = getViewWindowBounds() || {start: chartTimeBounds.min, end: chartTimeBounds.max};
        const range = Math.max(1, chartTimeBounds.max - chartTimeBounds.min);
        const startRatio = (bounds.start - chartTimeBounds.min) / range;
        const endRatio = (bounds.end - chartTimeBounds.min) / range;
        return {
            start: Math.max(0, Math.min(1, startRatio)),
            end: Math.max(0, Math.min(1, endRatio)),
        };
    }

    function isPointInTimeline(y, metrics = getTimelineMetrics()) {
        return y >= metrics.top && y <= metrics.top + metrics.height;
    }

    function updateOffsetFromStartRatio(startRatio) {
        const available = Math.max(0, 1 - chartViewSpan);
        if (available <= 0) {
            chartViewOffsetRatio = 0;
            return;
        }
        const normalized = Number.isFinite(startRatio) ? startRatio : 0;
        chartViewOffsetRatio = Math.max(0, Math.min(1, normalized / available));
    }

    function clampStartRatio(value) {
        const maxStart = Math.max(0, 1 - chartViewSpan);
        const normalized = Number.isFinite(value) ? value : 0;
        return Math.max(0, Math.min(maxStart, normalized));
    }

    function drawGrid(ctx, padding, width, height, priceMin, priceMax) {
        const steps = PRICE_GRID_STEPS; // e.g. 0.05 increments across [0, 1]
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 6]);
        ctx.beginPath();
        for (let i = 0; i <= steps; i++) {
            const y = padding.top + (height / steps) * i;
            ctx.moveTo(padding.left, y);
            ctx.lineTo(padding.left + width, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = "#94a3b8";
        ctx.font = "12px system-ui";
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        for (let i = 0; i <= steps; i++) {
            const price = priceMax - ((priceMax - priceMin) / steps) * i;
            const y = padding.top + (height / steps) * i;
            ctx.fillText(price.toFixed(2), padding.left - 6, y);
        }
    }

    function drawLineSeries(ctx, series, xFor, yFor, padding, chartHeight) {
        ctx.beginPath();
        ctx.strokeStyle = series.color;
        ctx.lineWidth = 2;
        series.points.forEach((point, idx) => {
            const x = xFor(point.time);
            const y = yFor(point.price);
            if (idx === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        drawSeriesLabel(ctx, series, xFor, yFor, padding, chartHeight);
    }

    function drawSeriesLabel(ctx, series, xFor, yFor, padding, chartHeight) {
        const lastPoint = series.points[series.points.length - 1];
        if (!lastPoint) return;
        const x = xFor(lastPoint.time) + 6;
        const y = yFor(lastPoint.price);
        const minY = padding.top + 8;
        const maxY = padding.top + chartHeight - 8;
        const clampedY = Math.max(minY, Math.min(maxY, y));
        ctx.font = "12px system-ui";
        ctx.fillStyle = series.color;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText(series.label, x, clampedY);
    }

    function handleTimelinePointerDown(event) {
        if (!chartCanvas || !chartTimeBounds) return;
        const metrics = getTimelineMetrics();
        const pos = getTimelinePosition(event, metrics);
        if (!isPointInTimeline(pos.y, metrics)) return;
        event.preventDefault();
        const ratios = getWindowRatios();
        const startRatio = ratios.start;
        const endRatio = ratios.end;
        const handleSize = 12;
        const startX = ratioToTimelineX(startRatio, metrics);
        const endX = ratioToTimelineX(endRatio, metrics);
        let mode = "move";
        if (Math.abs(pos.x - startX) <= handleSize) {
            mode = "resize-start";
        } else if (Math.abs(pos.x - endX) <= handleSize) {
            mode = "resize-end";
        } else if (pos.x < startX || pos.x > endX) {
            mode = "jump";
        }
        if (mode === "jump") {
            jumpTimelineToPosition(pos.x, metrics);
            return;
        }
        timelineDragState = {
            pointerId: event.pointerId,
            mode,
            metrics,
            originX: pos.x,
            initialStartRatio: startRatio,
            initialEndRatio: endRatio,
        };
        chartCanvas.setPointerCapture(event.pointerId);
    }

    function handleTimelinePointerMove(event) {
        if (!timelineDragState || timelineDragState.pointerId !== event.pointerId) return;
        const metrics = timelineDragState.metrics;
        const pos = getTimelinePosition(event, metrics);
        const deltaRatio = (pos.x - timelineDragState.originX) / metrics.usableWidth;
        applyTimelineDrag(deltaRatio);
    }

    function handleTimelinePointerUp(event) {
        if (chartCanvas?.hasPointerCapture?.(event.pointerId)) {
            chartCanvas.releasePointerCapture(event.pointerId);
        }
        timelineDragState = null;
    }

    function applyTimelineDrag(deltaRatio) {
        if (!timelineDragState) return;
        const state = timelineDragState;
        if (state.mode === "move") {
            const newStart = clampStartRatio(state.initialStartRatio + deltaRatio);
            updateOffsetFromStartRatio(newStart);
        } else if (state.mode === "resize-start") {
            let newStart = state.initialStartRatio + deltaRatio;
            const maxStart = state.initialEndRatio - CHART_ZOOM_MIN;
            newStart = Math.min(newStart, maxStart);
            newStart = Math.max(0, newStart);
            const newSpan = state.initialEndRatio - newStart;
            chartViewSpan = clampZoomSpan(newSpan);
            const adjustedStart = clampStartRatio(newStart);
            updateOffsetFromStartRatio(adjustedStart);
        } else if (state.mode === "resize-end") {
            let newEnd = state.initialEndRatio + deltaRatio;
            newEnd = Math.max(state.initialStartRatio + CHART_ZOOM_MIN, newEnd);
            newEnd = Math.min(1, newEnd);
            const newSpan = newEnd - state.initialStartRatio;
            chartViewSpan = clampZoomSpan(newSpan);
            const adjustedStart = clampStartRatio(state.initialStartRatio);
            updateOffsetFromStartRatio(adjustedStart);
        }
        redrawChartWithCurrentView();
    }

    function jumpTimelineToPosition(x, metrics) {
        if (!chartTimeBounds) return;
        const targetRatio = positionToTimelineRatio(x, metrics);
        const centeredStart = clampStartRatio(targetRatio - chartViewSpan / 2);
        updateOffsetFromStartRatio(centeredStart);
        redrawChartWithCurrentView();
    }

    function buildPoints(history) {
        return history.slice().sort((a, b) => a.t - b.t).map(entry => ({
            time: normalizeTimestamp(entry.t),
            price: Number(entry.p),
        })).filter(point => Number.isFinite(point.time) && Number.isFinite(point.price));
    }

    function normalizeTimestamp(value) {
        const num = Number(value);
        if (Number.isNaN(num)) return Date.now();
        return num > 1e12 ? num : num * 1000;
    }

    async function safeJson(res) {
        try {
            return await res.json();
        } catch (_) {
            return null;
        }
    }

    function getChartColor(index) {
        if (CHART_COLORS[index]) return CHART_COLORS[index];
        const hue = (index * 47) % 360;
        return `hsl(${hue} 70% 60%)`;
    }

    TAG_OPTIONS.forEach(option => {
        if (!tagSelect) return;
        const opt = document.createElement("option");
        opt.value = String(option.id);
        opt.textContent = `${option.label}`;
        tagSelect.appendChild(opt);
    });
    if (tagSelect) tagSelect.value = String(currentTagId);
    if (eventSelect) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "加载事件…";
        opt.disabled = true;
        opt.selected = true;
        eventSelect.appendChild(opt);
        eventSelect.disabled = true;
    }

    if (chartIntervalSelect) {
        CHART_INTERVALS.forEach(({value, label}) => {
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            chartIntervalSelect.appendChild(opt);
        });
        chartIntervalSelect.value = chartInterval;
        chartIntervalSelect.addEventListener("change", () => {
            chartInterval = chartIntervalSelect.value;
            refreshYesTokenChart(lastRenderedMarkets);
        });
    }
    if (chartCanvas) {
        chartCanvas.addEventListener("pointerdown", handleTimelinePointerDown);
        chartCanvas.addEventListener("pointermove", handleTimelinePointerMove);
        chartCanvas.addEventListener("pointerup", handleTimelinePointerUp);
        chartCanvas.addEventListener("pointercancel", handleTimelinePointerUp);
        chartCanvas.addEventListener("pointerleave", handleTimelinePointerUp);
    }
    if (chartSelectAllBtn) {
        chartSelectAllBtn.addEventListener("click", () => {
            chartTokens.forEach(token => selectedChartTokenIds.add(token.tokenId));
            renderChartTokenList();
            renderChartFromCache();
        });
    }
    if (chartClearAllBtn) {
        chartClearAllBtn.addEventListener("click", () => {
            selectedChartTokenIds.clear();
            renderChartTokenList();
            renderChartFromCache();
        });
    }

    function getTagLabel(tagId) {
        const option = TAG_OPTIONS.find(opt => opt.id === tagId);
        return option ? option.label : null;
    }

    async function fetchMarkets(tagId) {
        const query = Number.isFinite(tagId) ? `?tag=${encodeURIComponent(tagId)}` : "";
        const res = await fetch(`${API}${query}`);
        if (!res.ok) throw new Error("网络请求失败");
        const payload = await res.json();
        const list = Array.isArray(payload) ? payload : [];
        return list;
    }

    function render(data) {
        const tbody = $("rows");
        tbody.innerHTML = "";
        data.forEach(item => {
            const tr = document.createElement("tr");
            fields.forEach(f => {
                const td = document.createElement("td");
                td.dataset.th = f.label;
                if (f.className) td.classList.add(f.className);
                const span = document.createElement("span");
                span.className = "cell-value";
                const value = formatValue(item[f.key], f);
                span.textContent = value;
                if (f.key === "question" && typeof value === "string") {
                    span.title = value;
                } else if (dateFieldRegex.test(f.key) && typeof value === "string") {
                    span.title = value;
                } else if (f.key === "outcomes") {
                    const parsed = parseOutcomes(item[f.key]);
                    if (parsed) {
                        span.title = parsed.join(" / ");
                    } else if (typeof item[f.key] === "string") {
                        span.title = item[f.key];
                    }
                }
                td.appendChild(span);
                tr.appendChild(td);
            });
            const detailTd = document.createElement("td");
            detailTd.dataset.th = "详细";
            const btn = document.createElement("button");
            btn.className = "detail-trigger";
            btn.textContent = "查看";
            btn.addEventListener("click", () => showDetail(item));
            detailTd.appendChild(btn);
            tr.appendChild(detailTd);
            tbody.appendChild(tr);
        });
    }

    function pickDetail(item) {
        return detailKeys.reduce((acc, key) => {
            if (item[key] === undefined) return acc;
            if (key === "events" && Array.isArray(item.events)) {
                acc[key] = item.events.map(evt => {
                    return eventDetailKeys.reduce((evtAcc, evtKey) => {
                        if (evt && evt[evtKey] !== undefined) evtAcc[evtKey] = evt[evtKey];
                        return evtAcc;
                    }, {});
                });
                return acc;
            }
            acc[key] = item[key];
            return acc;
        }, {});
    }

    function showDetail(item) {
        const panel = $("detailPanel");
        const title = $("detailTitle");
        const json = $("detailJson");
        const filtered = pickDetail(item);
        title.textContent = filtered.question || filtered.id || "详情";
        json.textContent = JSON.stringify(filtered, null, 2);
        panel.classList.add("active");
    }

    function hideDetail() {
        $("detailPanel").classList.remove("active");
    }

    function updateStatus(visibleCount) {
        if (!statusEl) return;
        if (!currentData.length) {
            const label = getTagLabel(currentTagId);
            statusEl.textContent = label ? `暂无 ${label} 数据` : "暂无数据";
            return;
        }
        const label = getTagLabel(currentTagId);
        const parts = [
            `已载入 ${currentData.length} 条`,
            `显示 ${visibleCount} 条`,
        ];
        if (label) parts.push(`标签：${label}`);
        if (currentEventTicker) parts.push(`事件：${currentEventTicker}`);
        statusEl.textContent = parts.join("，");
    }

    function refreshView() {
        const outcomeFiltered = filterByOutcomeMode(currentData);
        updateEventFilterOptions(outcomeFiltered);
        const byEvent = filterByEvent(outcomeFiltered);
        const sorted = sortMarkets(byEvent);
        render(sorted);
        updateStatus(sorted.length);
        lastRenderedMarkets = sorted;
        refreshYesTokenChart(sorted);
    }

    function normalizeTagId(tagId) {
        const matched = TAG_OPTIONS.find(opt => opt.id === tagId);
        return matched ? matched.id : DEFAULT_TAG_ID;
    }

    async function load(tagId = currentTagId) {
        currentTagId = normalizeTagId(tagId);
        if (tagSelect) tagSelect.value = String(currentTagId);
        statusEl.textContent = "加载中…";
        reloadBtn.disabled = true;
        outcomeToggleBtn.disabled = true;
        if (tagSelect) tagSelect.disabled = true;
        if (eventSelect) eventSelect.disabled = true;
        try {
            const data = await fetchMarkets(currentTagId);
            currentData = enrichMarketStats(data);
            refreshView();
        } catch (err) {
            console.error(err);
            statusEl.textContent = "加载失败，请稍后重试";
        } finally {
            reloadBtn.disabled = false;
            outcomeToggleBtn.disabled = false;
            if (tagSelect) tagSelect.disabled = false;
            if (eventSelect) {
                const optionCount = eventSelect.options.length;
                eventSelect.disabled = optionCount <= 1;
            }
        }
    }

    function updateOutcomeButton() {
        outcomeToggleBtn.textContent = outcomeMode === "yesno" ? "筛选：YES/NO" : "筛选：Up/Down";
    }

    $("reload").addEventListener("click", () => load());
    $("outcomeToggle").addEventListener("click", () => {
        outcomeMode = outcomeMode === "yesno" ? "updown" : "yesno";
        updateOutcomeButton();
        refreshView();
    });
    if (tagSelect) {
        tagSelect.addEventListener("change", (evt) => {
            const nextTag = Number.parseInt(evt.target.value, 10);
            load(Number.isNaN(nextTag) ? DEFAULT_TAG_ID : nextTag);
        });
    }
    if (eventSelect) {
        eventSelect.addEventListener("change", (evt) => {
            currentEventTicker = evt.target.value || null;
            refreshView();
        });
    }
    $("detailClose").addEventListener("click", hideDetail);
    $("detailPanel").addEventListener("click", (evt) => {
        if (evt.target === evt.currentTarget) hideDetail();
    });
    window.addEventListener("resize", () => {
        if (lastChartDatasets.length) {
            drawChartWithView(lastChartDatasets);
        } else {
            drawTimeline();
        }
    });
    drawTimeline();
    setChartWindowInfo();
    updateOutcomeButton();
    load();
</script>
</body>
</html>
