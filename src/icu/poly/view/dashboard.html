<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <title>Polymarket 仓位看板（最小可用）</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root {
            --bg: #0b0f14;
            --card: #121821;
            --muted: #9aa6b2;
            --text: #e6edf3;
            --green: #2ecc71;
            --red: #ff6b6b;
            --line: #1e2633;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--text);
            font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        }

        .wrap {
            width: 100%;
            max-width: none;
            margin: 0;
            padding: 24px 16px;
            box-sizing: border-box;
        }

        .title {
            font-size: 18px;
            margin: 0 0 12px 0;
        }

        .subtitle {
            font-size: 16px;
            margin: 0;
        }

        .bar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 12px;
        }

        input,
        button {
            background: #0f141c;
            border: 1px solid var(--line);
            color: var(--text);
            padding: 8px 10px;
            border-radius: 8px;
        }

        input:not([type="checkbox"]) {
            min-width: 420px;
            flex: 1 1 420px;
        }

        button {
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        button:hover {
            background: #1a2332;
            border-color: #2d3a4e;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .close-order {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .close-order input {
            min-width: 80px;
            flex: 0 0 80px;
            padding: 6px 8px;
            font-size: 12px;
        }

        .close-order button {
            min-width: 60px;
            padding: 6px 10px;
            font-size: 12px;
        }

        .price-cell {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .price-cell .label {
            font-size: 11px;
            color: var(--muted);
        }

        .summary {
            background: var(--card);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 10px 12px;
            margin: 12px 0;
            display: flex;
            gap: 24px;
            flex-wrap: wrap
        }

        .summary div {
            opacity: .9
        }

        .pnl-dashboard {
            background: var(--card);
            border: 1px solid var(--line);
            border-radius: 12px;
            padding: 16px 20px;
            margin: 12px 0 24px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
        }

        .pnl-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .pnl-item .label {
            font-size: 13px;
            color: var(--muted);
        }

        .pnl-item .value {
            font-size: 24px;
            font-weight: 600;
            line-height: 1.2;
        }

        .pnl-item .percent {
            font-size: 14px;
            opacity: 0.8;
        }

        .green {
            color: var(--green)
        }

        .red {
            color: var(--red)
        }

        .muted {
            color: var(--muted)
        }

        table {
            width: 100%;
            border-collapse: collapse;
            overflow: hidden;
            background: var(--card);
            border: 1px solid var(--line);
            border-radius: 12px;
        }

        thead th {
            font-weight: 600;
            padding: 10px;
            border-bottom: 1px solid var(--line);
            white-space: nowrap
        }

        tbody td {
            padding: 10px;
            border-top: 1px solid var(--line);
            vertical-align: middle
        }

        #tradeTable th,
        #tradeTable td {
            text-align: center;
        }

        #tbl th,
        #tbl td {
            text-align: center;
        }

        #tradeTable td.right {
            text-align: right;
        }

        #openOrderTable th,
        #openOrderTable td {
            text-align: center;
        }

        .asset {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            object-fit: cover;
            border: 1px solid var(--line)
        }

        .outcome {
            font-size: 12px;
            color: var(--muted)
        }

        .right {
            text-align: right;
            white-space: nowrap
        }

        .footer {
            margin: 14px 0 40px;
            color: var(--muted);
            font-size: 12px
        }

        .tip {
            font-size: 12px;
            color: var(--muted)
        }

        .chip {
            display: inline-block;
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 2px 8px;
            margin-left: 6px;
            font-size: 12px;
            color: var(--muted)
        }

        .home-link {
            display: inline-block;
            margin-left: 12px;
            padding: 6px 14px;
            background: #2ecc71;
            color: #0b0f14;
            border-radius: 999px;
            font-weight: 600;
            text-decoration: none;
            font-size: 13px;
            cursor: pointer;
            border: none;
        }

        .home-link:hover {
            opacity: 0.9;
        }

        .loading {
            opacity: .8
        }

        .section-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 32px 0 8px;
            gap: 12px;
            flex-wrap: wrap;
        }

        .section-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .section-actions label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
            user-select: none;
        }

        .section-actions label:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .section-actions input[type="checkbox"] {
            width: 18px;
            height: 18px;
            min-width: 18px;
            margin: 0;
            cursor: pointer;
            appearance: none;
            background: #1a2332;
            border: 2px solid #2d3a4e;
            border-radius: 4px;
            position: relative;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .section-actions input[type="checkbox"]:hover {
            border-color: #4a5f7f;
            background: #1f2a3a;
        }

        .section-actions input[type="checkbox"]:checked {
            background: var(--green);
            border-color: var(--green);
        }

        .section-actions input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            left: 5px;
            top: 2px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .section-actions label span {
            font-size: 14px;
            color: var(--text);
            transition: color 0.2s ease;
        }

        .section-actions button {
            padding: 8px 16px;
            font-size: 14px;
            min-width: auto;
        }

        a.link {
            color: #5dade2;
            text-decoration: none;
        }

        a.link:hover {
            text-decoration: underline;
        }

        .toast-container {
            position: fixed;
            right: 24px;
            bottom: 24px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 50;
        }

        .toast {
            background: rgba(18, 24, 33, 0.96);
            border: 1px solid var(--line);
            border-radius: 10px;
            padding: 12px 16px;
            min-width: 240px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            animation: fadeIn .2s ease;
        }

        .toast strong {
            display: block;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .toast button {
            margin-top: 8px;
            padding: 4px 8px;
            font-size: 12px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(12px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width:700px) {
            input[type="text"],
            input[type="number"] {
                min-width: 240px
            }

            thead {
                display: none
            }

            table,
            tbody,
            tr,
            td {
                display: block;
                width: 100%
            }

            tbody tr {
                border-top: 1px solid var(--line)
            }

            tbody td {
                display: flex;
                justify-content: space-between;
                gap: 12px
            }

            tbody td::before {
                content: attr(data-th);
                font-weight: 600;
                color: var(--muted)
            }

            .asset {
                justify-content: flex-end
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1 class="title">Polymarket 仓位看板 <span class="chip">最小可用</span> <a href="/" class="home-link">返回市场</a></h1>

        <div class="bar">
            <input id="addr" spellcheck="false" placeholder="输入地址（0x...）"
                value="" />
            <button id="refresh">刷新</button>
            <span id="status" class="muted"></span>
        </div>

        <div class="summary" id="summary">
            <div>持有价值：<b id="sumValue">—</b></div>
            <div>当前盈亏：<b id="sumPnl">—</b>（<span id="sumPnlPct">—</span>）</div>
            <div class="muted">仅展示 size ≥ 1 且 currentValue > 1 的持仓</div>
        </div>

        <div class="pnl-dashboard" id="pnlDashboard">
            <div class="pnl-item">
                <div class="label">当前浮动盈亏</div>
                <div class="value" id="currentPnl">—</div>
                <div class="percent" id="currentPnlPct">—</div>
            </div>
            <div class="pnl-item">
                <div class="label">最近24h盈亏</div>
                <div class="value" id="last24hPnl">—</div>
                <div class="percent" id="last24hPnlPct">—</div>
            </div>
            <div class="pnl-item">
                <div class="label">至今盈亏</div>
                <div class="value" id="totalPnl">—</div>
                <div class="percent" id="totalPnlPct">—</div>
            </div>
        </div>

        <div class="section-head">
            <h2 class="subtitle">持仓</h2>
            <div class="section-actions">
                <label>
                    <input type="checkbox" id="hideSmallPositions" />
                    <span>显示小额仓位</span>
                </label>
                <button id="positionRefresh">刷新持仓</button>
            </div>
        </div>

        <table id="tbl">
            <thead>
                <tr>
                    <th>资产</th>
                    <th>数量</th>
                    <th>成交价</th>
                    <th>最优买价</th>
                    <th>最优卖价</th>
                    <th>持有价值</th>
                    <th>当前盈亏</th>
                    <th>平仓</th>
                </tr>
            </thead>
            <tbody id="tbody"></tbody>
        </table>

        <div class="section-head">
            <h2 class="subtitle">当前挂单</h2>
            <div class="section-actions">
                <span id="openOrderStatus" class="muted">等待加载…</span>
                <button id="openOrderRefresh">刷新挂单</button>
            </div>
        </div>

        <table id="openOrderTable">
            <thead>
                <tr>
                    <th>订单ID</th>
                    <th>市场</th>
                    <th>方向</th>
                    <th>价格</th>
                    <th>初始数量</th>
                    <th>成交数量</th>
                    <th>状态</th>
                    <th>创建时间</th>
                    <th>操作</th>
                </tr>
            </thead>
            <tbody id="openOrderBody">
                <tr>
                    <td colspan="8" class="muted" data-th="提示">等待加载…</td>
                </tr>
            </tbody>
        </table>

        <div class="section-head">
            <h2 class="subtitle">最近成交（3天内，最多 50 条）</h2>
            <div class="section-actions">
                <span id="tradeStatus" class="muted">等待加载…</span>
                <button id="tradeRefresh">刷新成交</button>
            </div>
        </div>

        <table id="tradeTable">
            <thead>
                <tr>
                    <th>市场</th>
                    <th>订单ID</th>
                    <th>市场方向</th>
                    <th>订单方向</th>
                    <th>价格</th>
                    <th>数量</th>
                    <th>成交额</th>
                    <th>成交时间</th>
                    <th>Tx</th>
                </tr>
            </thead>
            <tbody id="tradeBody">
                <tr>
                    <td colspan="9" class="muted" data-th="提示">等待加载…</td>
                </tr>
            </tbody>
        </table>

        <div class="footer">
            <div class="tip">说明：持有价值按 <code>size × curPrice</code> 现场计算；盈亏使用接口返回
                <code>cashPnl / percentPnl</code>，若缺失则现场推导。</div>
        </div>
    </div>

    <div id="toastContainer" class="toast-container"></div>

    <script>
        const $ = (id) => document.getElementById(id);
        const f2 = (n = 0) => Number(n || 0).toFixed(2);
        const fmtMoney = (n) => Number.isFinite(Number(n)) ? '$' + f2(n) : '—';
        const PRICE_DISPLAY_MULTIPLIER = 100;
        const PRICE_DISPLAY_DECIMALS = 1;
        // 价格范围：双开区间 (0, 1)，不包含0和1
        const MIN_ORDER_PRICE = 0.0001; // 用于HTML input的min属性（接近0但不等于0）
        const MAX_ORDER_PRICE = 0.9999; // 用于HTML input的max属性（接近1但不等于1）
        const formatPrice = (value, { fallback = '—', withUnit = true } = {}) => {
            const num = Number(value);
            if (!Number.isFinite(num)) return fallback;
            const scaled = (num * PRICE_DISPLAY_MULTIPLIER).toFixed(PRICE_DISPLAY_DECIMALS);
            return withUnit ? `${scaled}%` : scaled;
        };
        const formatPriceInput = (value) => {
            return formatPrice(value, { fallback: '', withUnit: false });
        };
        const parsePriceInput = (value) => {
            const num = Number(value);
            return Number.isFinite(num) ? num / PRICE_DISPLAY_MULTIPLIER : Number.NaN;
        };
        const formatTs = (ts) => {
            const date = new Date(ts);
            return Number.isNaN(date.getTime()) ? '—' : date.toLocaleString('zh-CN', { hour12: false });
        };
        const shorten = (text = '', head = 6, tail = 4) => {
            if (!text) return '—';
            return text.length <= head + tail ? text : `${text.slice(0, head)}…${text.slice(-tail)}`;
        };
        const POLY_EVENT_BASE_URL = "https://polymarket.com/event/";
        const MIN_CURRENT_VALUE = 0.1;
        let cachedPositions = []; // 保存已加载的原始持仓数据

        async function fetchPositions(addr) {
            const url = `https://data-api.polymarket.com/positions?sizeThreshold=1&limit=100&sortBy=TOKENS&sortDirection=DESC&user=${addr}`;
            const res = await fetch(url, { mode: 'cors' });
            let text = await res.text();
            let data;
            try { data = JSON.parse(text); }
            catch (e) {
                const fixed = text
                    .replace(/([{,\s])(\w+)\s*:/g, '$1"$2":')
                    .replace(/'/g, '"');
                data = JSON.parse(fixed);
            }
            // 移除过滤逻辑，返回所有仓位，让 renderPositions 根据复选框状态决定是否过滤
            if (Array.isArray(data)) {
                return data;
            }
            return data;
        }

        async function fetchOrderBook(tokenId) {
            if (!tokenId) {
                return { bestBid: null, bestAsk: null };
            }
            try {
                const res = await fetch(`/api/best-prices/${tokenId}`);
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`HTTP ${res.status}: ${errorText}`);
                }
                const data = await res.json();
                return { bestBid: data.bestBid, bestAsk: data.bestAsk };
            } catch (err) {
                console.error(`Failed to fetch best prices for ${tokenId}:`, err);
                return { bestBid: null, bestAsk: null };
            }
        }

        async function placeCloseOrder(tokenId, price, size, side) {
            try {
                const res = await fetch('/api/place-order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tokenId, price, size, side })
                });
                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.message || `HTTP ${res.status}`);
                }
                return await res.json();
            } catch (err) {
                console.error('Failed to place order:', err);
                throw err;
            }
        }

        async function fetchTrades(addr) {
            const res = await fetch(`/api/trades?address=${addr}`);
            if (!res.ok) {
                const text = await res.text();
                throw new Error(text || `HTTP ${res.status}`);
            }
            return res.json();
        }

        async function fetchOpenOrders() {
            const res = await fetch(`/api/open-orders`);
            if (!res.ok) {
                const text = await res.text();
                throw new Error(text || `HTTP ${res.status}`);
            }
            return res.json();
        }

        async function fetchCurrentAddress() {
            const res = await fetch('/api/current-address');
            if (!res.ok) {
                const text = await res.text();
                throw new Error(text || `HTTP ${res.status}`);
            }
            const data = await res.json();
            return data.address;
        }

        async function renderPositions(rows) {
            const tbody = $('tbody');
            tbody.innerHTML = '';

            // 先用 curPrice 判断哪些是小额仓位，小额仓位永远不调用订单簿API
            const showSmall = $('hideSmallPositions')?.checked || false;

            // 判断是否为小额仓位（基于 curPrice）
            const isSmallPosition = (r) => {
                const size = Number(r.size ?? 0);
                const cur = Number(r.curPrice ?? 0);
                const currentValue = size * cur;
                return currentValue <= MIN_CURRENT_VALUE;
            };

            // 只对非小额仓位获取订单簿数据（小额仓位永远不调用API）
            const nonSmallRows = rows.filter(r => !isSmallPosition(r));
            const tokenIdSet = new Set();
            nonSmallRows.forEach(r => {
                const tokenId = r.asset || r.tokenId || r.asset_id || r.assetId || r.token_id || '';
                if (tokenId) tokenIdSet.add(tokenId);
            });

            // 只对非小额仓位获取订单簿数据
            const orderBookMap = new Map();
            await Promise.all(Array.from(tokenIdSet).map(async (tokenId) => {
                const { bestBid, bestAsk } = await fetchOrderBook(tokenId);
                orderBookMap.set(tokenId, { bestBid, bestAsk });
            }));

            // 为所有仓位添加订单簿数据（只对非小额仓位有数据，小额仓位永远为 null）
            const enrichedRows = rows.map(r => {
                const tokenId = r.asset || r.tokenId || r.asset_id || r.assetId || r.token_id || '';
                // 小额仓位永远不调用API，订单簿数据为 null
                const orderBook = orderBookMap.get(tokenId) || { bestBid: null, bestAsk: null };
                return { ...r, ...orderBook, tokenId };
            });

            // 根据单选框状态过滤小额仓位：选中时显示小额仓位，未选中时隐藏小额仓位
            const filteredRows = showSmall
                ? enrichedRows // 选中时显示所有仓位（包括小额）
                : enrichedRows.filter(r => !isSmallPosition(r)); // 未选中时隐藏小额仓位

            // 用于计算盈亏的仓位：始终排除小额仓位，不管复选框状态
            const nonSmallRowsForCalc = enrichedRows.filter(r => !isSmallPosition(r));

            // 基于非小额仓位计算盈亏（非小额仓位已经有订单簿数据）
            let totalValue = 0, totalPnl = 0, totalCost = 0;
            // 统一使用最优买价作为标记价格，缺失时退回当前价
            const getMarkPrice = (row) => {
                if (Number.isFinite(row.bestBid)) {
                    return Number(row.bestBid);
                }
                const fallback = Number(row.curPrice ?? 0);
                return Number.isFinite(fallback) ? fallback : 0;
            };

            nonSmallRowsForCalc.forEach(r => {
                const size = Number(r.size ?? 0);
                const avg = Number(r.avgPrice ?? 0);
                const markPrice = getMarkPrice(r);
                const holdValue = size * markPrice;
                const costValue = size * avg;
                const cashPnl = holdValue - costValue;
                totalValue += holdValue;
                totalPnl += cashPnl;
                totalCost += costValue;
            });

            // 基于过滤后的列表显示持仓（根据复选框状态）
            filteredRows.forEach(r => {
                const title = r.title || r.slug || r.asset || '—';
                const outcome = r.outcome ? `（${r.outcome}）` : '';
                const icon = r.icon || '';
                const size = Number(r.size ?? 0);
                const avg = Number(r.avgPrice ?? 0);
                const tokenId = r.tokenId;
                const bestBid = r.bestBid;
                const bestAsk = r.bestAsk;
                const markPrice = getMarkPrice(r);
                const holdValue = size * markPrice;
                const costValue = size * avg;
                const cashPnl = holdValue - costValue;
                const percentPnl = costValue ? (cashPnl / costValue) : 0;

                // 注意：盈亏计算已在 nonSmallRows 中完成，这里只用于显示单行数据

                const tr = document.createElement('tr');
                const rowId = `row-${tokenId || Math.random().toString(36).slice(2, 9)}`;
                tr.id = rowId;

                tr.innerHTML = `
          <td class="asset" data-th="资产">
            ${icon ? `<img class="icon" src="${icon}" alt="">` : ''}
            <div>
              <div>${title}</div>
              <div class="outcome">${r.eventSlug ? r.eventSlug + ' · ' : ''}${outcome}</div>
            </div>
          </td>
          <td class="right" data-th="数量">${size}</td>
          <td class="right" data-th="成交价">${formatPrice(avg)}</td>
          <td class="right" data-th="最优买价">
            ${Number.isFinite(bestBid) ? `<span class="green">${formatPrice(bestBid)}</span>` : '<span class="muted">—</span>'}
          </td>
          <td class="right" data-th="最优卖价">
            ${Number.isFinite(bestAsk) ? `<span class="red">${formatPrice(bestAsk)}</span>` : '<span class="muted">—</span>'}
          </td>
          <td class="right" data-th="持有价值">${fmtMoney(holdValue)}</td>
          <td class="right" data-th="当前盈亏">
            <span class="${cashPnl >= 0 ? 'green' : 'red'}">${(cashPnl >= 0 ? '+' : '') + fmtMoney(cashPnl)}</span>
            <span class="${percentPnl >= 0 ? 'green' : 'red'}"> (${(percentPnl >= 0 ? '+' : '') + (percentPnl * 100).toFixed(2)}%)</span>
          </td>
          <td class="close-order" data-th="平仓">
            <input type="number" step="0.1" min="${MIN_ORDER_PRICE * PRICE_DISPLAY_MULTIPLIER}" max="${MAX_ORDER_PRICE * PRICE_DISPLAY_MULTIPLIER}" placeholder="价格（%）"
                   id="${rowId}-price" value="${formatPriceInput(bestBid)}" />
            <input type="number" step="0.01" min="0.01" placeholder="数量"
                   id="${rowId}-size" value="${size > 0 ? size.toFixed(3) : ''}" max="${size}" />
            <button${Number.isFinite(bestBid) ? ` data-best-bid="${bestBid}"` : ''} onclick="handleCloseOrder('${tokenId}', '${rowId}', 'SELL')">平仓</button>
          </td>
        `;
                tbody.appendChild(tr);
            });

            $('sumValue').textContent = fmtMoney(totalValue);
            const pnlPct = totalCost ? (totalPnl / totalCost) : 0;
            $('sumPnl').innerHTML = `<span class="${totalPnl >= 0 ? 'green' : 'red'}">${(totalPnl >= 0 ? '+' : '') + fmtMoney(totalPnl)}</span>`;
            $('sumPnlPct').innerHTML = `<span class="${pnlPct >= 0 ? 'green' : 'red'}">${(pnlPct * 100).toFixed(2)}%</span>`;

            // 更新当前浮动盈亏到收益看板（只更新当前浮动盈亏，不覆盖已实现盈亏）
            const currentPnlEl = $('currentPnl');
            const currentPnlPctEl = $('currentPnlPct');
            if (currentPnlEl) {
                const colorClass = totalPnl >= 0 ? 'green' : 'red';
                currentPnlEl.innerHTML = `<span class="${colorClass}">${(totalPnl >= 0 ? '+' : '') + fmtMoney(totalPnl)}</span>`;
            }
            if (currentPnlPctEl) {
                const colorClass = pnlPct >= 0 ? 'green' : 'red';
                currentPnlPctEl.innerHTML = `<span class="${colorClass}">${(pnlPct >= 0 ? '+' : '') + (pnlPct * 100).toFixed(2)}%</span>`;
            }

            // 返回计算好的盈亏数据，供外部使用
            return { currentPnl: totalPnl, currentPnlPct: pnlPct };
        }

        function parseOrderTime(value) {
            if (!value) return '—';
            if (typeof value === 'number') {
                return formatTs(value > 1e12 ? value : value * 1000);
            }
            const asNumber = Number(value);
            if (!Number.isNaN(asNumber)) {
                return formatTs(asNumber > 1e12 ? asNumber : asNumber * 1000);
            }
            const parsed = Date.parse(value);
            return Number.isNaN(parsed) ? '—' : formatTs(parsed);
        }

        function renderOpenOrders(orders = []) {
            const tbody = $('openOrderBody');
            const status = $('openOrderStatus');
            tbody.innerHTML = '';
            if (!Array.isArray(orders) || !orders.length) {
                status.textContent = '暂无挂单';
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="9" class="muted" data-th="提示">暂无挂单</td>`;
                tbody.appendChild(tr);
                return;
            }
            status.textContent = `共有 ${orders.length} 条挂单`;
            orders.forEach(order => {
                const sideLabel = (order.side || order.action || '—').toUpperCase();
                const price = Number(order.price ?? order.limit_price ?? 0);
                const remaining = Number(order.size_matched ?? order.remaining ?? order.size ?? 0);
                const original = Number(order.original_size ?? order.making_amount ?? order.total_size ?? remaining);
                const slug = order.marketSlug || order.slug || null;
                const marketLabel = order.marketQuestion || order.question || order.market || (slug ? shorten(slug) : '—');
                const marketCell = slug
                    ? `<a class="link" href="${POLY_EVENT_BASE_URL}${slug}" target="_blank" rel="noreferrer">${marketLabel}</a>`
                    : marketLabel;
                const tr = document.createElement('tr');
                tr.innerHTML = `
        <td data-th="订单ID">${shorten(order.id || order.order_id || '')}</td>
        <td data-th="市场">${marketCell}</td>
        <td data-th="方向"><span class="${sideLabel.includes('BUY') || sideLabel.includes('BID') ? 'green' : 'red'}">${sideLabel}</span></td>
        <td data-th="价格">${formatPrice(price)}</td>
        <td data-th="初始数量">${f2(original)}</td>
        <td data-th="成交数量">${f2(remaining)}</td>
        <td data-th="状态">${order.status || order.state || 'live'}</td>
        <td data-th="创建时间">${parseOrderTime(order.created_time || order.created_at || order.timestamp)}</td>
        <td data-th="操作">
          <button class="cancel-btn" data-order-id="${order.id || order.order_id || ''}">撤单</button>
        </td>
      `;
                tbody.appendChild(tr);
            });

            tbody.querySelectorAll('.cancel-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const orderId = button.dataset.orderId;
                    if (!orderId) {
                        alert('缺少 orderId，无法撤单');
                        return;
                    }
                    cancelOpenOrder(orderId, button);
                });
            });
        }

        async function refreshOpenOrdersSection() {
            const status = $('openOrderStatus');
            if (status) {
                status.textContent = '刷新挂单…';
                status.classList.add('loading');
            }
            try {
                const orders = await fetchOpenOrders();
                renderOpenOrders(Array.isArray(orders) ? orders : []);
            } catch (err) {
                console.error('Failed to refresh open orders:', err);
                if (status) status.textContent = '挂单刷新失败';
                const tbody = $('openOrderBody');
                if (tbody) {
                    tbody.innerHTML = `<tr><td colspan="9" class="muted" data-th="提示">挂单刷新失败</td></tr>`;
                }
            } finally {
                if (status) status.classList.remove('loading');
            }
        }

        async function refreshTradesSection(addr) {
            const tradeHint = $('tradeStatus');
            if (tradeHint) {
                tradeHint.textContent = '刷新成交…';
                tradeHint.classList.add('loading');
            }
            try {
                const trades = await fetchTrades(addr);
                renderTrades(Array.isArray(trades) ? trades : []);
            } catch (err) {
                console.error('Failed to refresh trades:', err);
                if (tradeHint) tradeHint.textContent = '成交刷新失败';
                const tbody = $('tradeBody');
                if (tbody) {
                    tbody.innerHTML = `<tr><td colspan="9" class="muted" data-th="提示">成交刷新失败</td></tr>`;
                }
            } finally {
                if (tradeHint) tradeHint.classList.remove('loading');
            }
        }

        async function refreshPositionsSection(addr) {
            const st = $('status');
            if (st) {
                st.textContent = '刷新资产…';
                st.classList.add('loading');
            }
            try {
                const rows = await fetchPositions(addr);
                cachedPositions = Array.isArray(rows) ? rows : [];
                await renderPositions(cachedPositions);
                if (st) st.textContent = `已加载 ${cachedPositions.length} 条持仓`;
            } catch (err) {
                console.error('Failed to refresh positions:', err);
                if (st) st.textContent = '资产刷新失败';
            } finally {
                if (st) st.classList.remove('loading');
            }
        }

        // 重新渲染已缓存的持仓数据（不重新获取）
        async function rerenderCachedPositions() {
            if (cachedPositions.length > 0) {
                await renderPositions(cachedPositions);
            }
        }

        const toastContainer = $('toastContainer');

        function showToast({ title = '提示', message = '' }) {
            if (!toastContainer) return;
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `<strong>${title}</strong><div>${message}</div>`;
            toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.remove();
            }, 4000);
        }

        async function cancelOpenOrder(orderId, button) {
            if (!orderId) return;
            const confirmed = confirm(`确认撤销订单 ${shorten(orderId)} 吗？`);
            if (!confirmed) return;
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = "撤单中…";
            try {
                const res = await fetch("/api/cancel-order", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ orderId }),
                });
                if (!res.ok) {
                    const body = await res.json().catch(() => ({}));
                    throw new Error(body?.message || body?.error || `HTTP ${res.status}`);
                }
                await refreshOpenOrdersSection();
                showToast({ title: '撤单成功', message: `订单 ${shorten(orderId)} 已撤销` });
            } catch (err) {
                alert(`撤单失败：${err.message || err}`);
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        function renderTrades(trades) {
            const tbody = $('tradeBody');
            const status = $('tradeStatus');
            tbody.innerHTML = '';

            const normalizeNumber = (value) => {
                if (value === undefined || value === null) return 0;
                const num = Number(value);
                return Number.isFinite(num) ? num : 0;
            };

            const flatTrades = Array.isArray(trades) ? trades.flat() : [];

            if (!flatTrades.length) {
                status.textContent = '最近3天暂无成交';
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="9" class="muted" data-th="提示">最近3天暂无成交</td>`;
                tbody.appendChild(tr);
                return;
            }

            flatTrades.forEach(trade => {
                const price = normalizeNumber(trade.price ?? trade.order_price);
                const size = normalizeNumber(trade.matched_amount ?? trade.size ?? trade.amount);
                const notional = price * size;
                const rawMatchTime = trade.match_time ?? trade.matchTime;
                const numericMatchTime = Number(rawMatchTime);
                const matchTime = Number.isFinite(numericMatchTime) && numericMatchTime > 0
                    ? numericMatchTime * 1000
                    : undefined;
                const marketLabel = trade.question || '—';
                const orderIdLabel = shorten(trade.order_id || trade.orderId || '');
                const outcome = trade.outcome || '—';
                const trEl = document.createElement('tr');
                trEl.innerHTML = `
        <td data-th="市场">${marketLabel}</td>
        <td data-th="订单ID">${orderIdLabel}</td>
        <td data-th="市场方向">${outcome}</td>
        <td data-th="订单方向"><span class="${trade.side === 'BUY' ? 'green' : 'red'}">${trade.side || '—'}</span></td>
        <td data-th="价格" class="right">${formatPrice(price)}</td>
        <td data-th="数量" class="right">${f2(size)}</td>
        <td data-th="成交额" class="right">${fmtMoney(notional)}</td>
        <td data-th="成交时间">${formatTs(matchTime)}</td>
        <td data-th="Tx">
          ${trade.transactionHash
                        ? `<a class="link" href="https://polygonscan.com/tx/${trade.transactionHash}" target="_blank" rel="noreferrer">${shorten(trade.transactionHash)}</a>`
                        : '<span class="muted">—</span>'}
        </td>`;
                tbody.appendChild(trEl);
            });

            status.textContent = `最近 ${flatTrades.length} 条成交（≤3天）`;
        }

        function calculateRealizedPnl(trades) {
            if (!Array.isArray(trades)) return { last24h: 0, total: 0 };

            const flatTrades = trades.flat();
            const now = Date.now();
            const last24h = now - 24 * 60 * 60 * 1000;

            const normalizeNumber = (value) => {
                if (value === undefined || value === null) return 0;
                const num = Number(value);
                return Number.isFinite(num) ? num : 0;
            };

            // 按 tokenId 分组，计算每个 token 的已实现盈亏
            const tokenMap = new Map();

            flatTrades.forEach(trade => {
                const tokenId = trade.asset_id || trade.assetId || trade.token_id || trade.tokenId || '';
                const price = normalizeNumber(trade.price ?? trade.order_price);
                const size = normalizeNumber(trade.matched_amount ?? trade.size ?? trade.amount);
                const side = (trade.side || '').toUpperCase();
                const rawMatchTime = trade.match_time ?? trade.matchTime;
                const numericMatchTime = Number(rawMatchTime);
                const matchTime = Number.isFinite(numericMatchTime) && numericMatchTime > 0
                    ? numericMatchTime * 1000
                    : undefined;

                if (!tokenId || !matchTime) return;

                if (!tokenMap.has(tokenId)) {
                    tokenMap.set(tokenId, []);
                }
                tokenMap.get(tokenId).push({ price, size, side, matchTime });
            });

            let last24hPnl = 0;
            let totalPnl = 0;

            // 对每个 token 计算已实现盈亏（FIFO 方法）
            tokenMap.forEach((trades, tokenId) => {
                // 按时间排序
                trades.sort((a, b) => a.matchTime - b.matchTime);

                const buyQueue = [];
                let last24hRealized = 0;
                let totalRealized = 0;

                trades.forEach(trade => {
                    const isLast24h = trade.matchTime >= last24h;

                    if (trade.side === 'BUY' || trade.side === 'BID') {
                        buyQueue.push({ price: trade.price, size: trade.size, matchTime: trade.matchTime });
                    } else if (trade.side === 'SELL' || trade.side === 'ASK') {
                        let remaining = trade.size;

                        while (remaining > 0 && buyQueue.length > 0) {
                            const buy = buyQueue[0];
                            const matched = Math.min(remaining, buy.size);
                            const pnl = (trade.price - buy.price) * matched;

                            if (isLast24h || buy.matchTime >= last24h) {
                                last24hRealized += pnl;
                            }
                            totalRealized += pnl;

                            remaining -= matched;
                            buy.size -= matched;

                            if (buy.size <= 0) {
                                buyQueue.shift();
                            }
                        }
                    }
                });

                last24hPnl += last24hRealized;
                totalPnl += totalRealized;
            });

            return { last24h: last24hPnl, total: totalPnl };
        }

        function updatePnlDashboard({ currentPnl, currentPnlPct, last24hPnl, totalPnl }) {
            const currentPnlEl = $('currentPnl');
            const currentPnlPctEl = $('currentPnlPct');
            const last24hPnlEl = $('last24hPnl');
            const last24hPnlPctEl = $('last24hPnlPct');
            const totalPnlEl = $('totalPnl');
            const totalPnlPctEl = $('totalPnlPct');

            // 当前浮动盈亏（只在传入时更新）
            if (currentPnl !== undefined && currentPnlEl) {
                const colorClass = currentPnl >= 0 ? 'green' : 'red';
                currentPnlEl.innerHTML = `<span class="${colorClass}">${(currentPnl >= 0 ? '+' : '') + fmtMoney(currentPnl)}</span>`;
            }
            if (currentPnlPct !== undefined && currentPnlPctEl) {
                const colorClass = currentPnlPct >= 0 ? 'green' : 'red';
                currentPnlPctEl.innerHTML = `<span class="${colorClass}">${(currentPnlPct >= 0 ? '+' : '') + (currentPnlPct * 100).toFixed(2)}%</span>`;
            }

            // 最近24h盈亏（只在传入时更新）
            if (last24hPnl !== undefined) {
                if (last24hPnlEl) {
                    if (last24hPnl === null) {
                        last24hPnlEl.textContent = '—';
                    } else {
                        const colorClass = last24hPnl >= 0 ? 'green' : 'red';
                        last24hPnlEl.innerHTML = `<span class="${colorClass}">${(last24hPnl >= 0 ? '+' : '') + fmtMoney(last24hPnl)}</span>`;
                    }
                }
                if (last24hPnlPctEl) {
                    last24hPnlPctEl.textContent = '';
                }
            }

            // 至今盈亏 = 当前浮动盈亏 + 已实现盈亏（只在传入时更新）
            if (totalPnl !== undefined && currentPnl !== undefined) {
                const total = currentPnl + totalPnl;
                if (totalPnlEl) {
                    if (totalPnl === null) {
                        totalPnlEl.textContent = '—';
                    } else {
                        const colorClass = total >= 0 ? 'green' : 'red';
                        totalPnlEl.innerHTML = `<span class="${colorClass}">${(total >= 0 ? '+' : '') + fmtMoney(total)}</span>`;
                    }
                }
                if (totalPnlPctEl) {
                    totalPnlPctEl.textContent = '';
                }
            }
        }

        async function handleCloseOrder(tokenId, rowId, side) {
            if (!tokenId) {
                alert('缺少 tokenId，无法平仓');
                return;
            }

            const priceInput = document.getElementById(`${rowId}-price`);
            const sizeInput = document.getElementById(`${rowId}-size`);
            const actionContainer = priceInput?.parentElement;
            const button = actionContainer?.querySelector('button');
            if (!priceInput || !sizeInput || !button) {
                alert('平仓控件缺失，请刷新页面后再试');
                return;
            }
            const price = parsePriceInput(priceInput.value);
            const size = Number(sizeInput.value);

            // 价格校验：双开区间 (0, 1)，不包含0和1
            if (!Number.isFinite(price) || price <= 0 || price >= 1) {
                alert(`请输入有效的价格（大于 0% 且小于 100%）`);
                return;
            }
            const bestBidAttr = button.dataset?.bestBid;
            const currentBestBid = Number(bestBidAttr);
            if (Number.isFinite(currentBestBid) && price < currentBestBid) {
                alert(`卖单价格需≥当前最优买价 ${formatPrice(currentBestBid)}`);
                return;
            }

            if (!size || size <= 0) {
                alert('请输入有效的数量');
                return;
            }

            // Round price to 3 decimal places to avoid floating point precision issues
            const roundedPrice = Math.round(price * 1000) / 1000;

            if (!confirm(`确认平仓？\n价格: ${formatPrice(roundedPrice)}\n数量: ${size}\n方向: ${side}`)) {
                return;
            }

            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = '提交中...';

            try {
                const result = await placeCloseOrder(tokenId, roundedPrice, size, side);
                console.log(result);
                if (result.error) {
                    alert(`平仓失败: ${result.error || '未知错误'}`);
                } else {
                    await refreshOpenOrdersSection();
                    showToast({
                        title: '平仓成功',
                        message: `订单 ${shorten(result.orderID || '')} 状态 ${result.status}`,
                    });
                    load();
                }
            } catch (err) {
                if (err?.code === 'not enough balance / allowance' || err?.message?.includes('not enough balance')) {
                    alert('平仓失败：账户余额或授权不足，请先补充/授权后再试。');
                } else {
                    alert(`平仓失败: ${err?.message || '未知错误'}`);
                }
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        async function load() {
            const addr = $('addr').value.trim();
            if (!addr || !addr.startsWith('0x') || addr.length < 10) {
                alert('请输入有效的钱包地址（0x...）'); return;
            }
            const st = $('status');
            const tradeHint = $('tradeStatus');
            const openOrderHint = $('openOrderStatus');
            st.textContent = '加载中…';
            st.classList.add('loading');
            tradeHint.textContent = '加载最近成交…';
            tradeHint.classList.add('loading');
            openOrderHint.textContent = '加载挂单…';
            openOrderHint.classList.add('loading');
            try {
                const [positionResult, openOrderResult, tradeResult] = await Promise.allSettled([
                    fetchPositions(addr),
                    fetchOpenOrders(),
                    fetchTrades(addr)
                ]);

                let trades = [];
                if (tradeResult.status === 'fulfilled') {
                    trades = Array.isArray(tradeResult.value) ? tradeResult.value : [];
                    renderTrades(trades);
                } else {
                    console.error(tradeResult.reason);
                    tradeHint.textContent = '成交加载失败';
                    const tbody = $('tradeBody');
                    tbody.innerHTML = `<tr><td colspan="9" class="muted" data-th="提示">成交列表加载失败</td></tr>`;
                }

                if (openOrderResult.status === 'fulfilled') {
                    renderOpenOrders(Array.isArray(openOrderResult.value) ? openOrderResult.value : []);
                } else {
                    console.error(openOrderResult.reason);
                    openOrderHint.textContent = '挂单加载失败';
                    const openBody = $('openOrderBody');
                    openBody.innerHTML = `<tr><td colspan="8" class="muted" data-th="提示">挂单列表加载失败</td></tr>`;
                }

                if (positionResult.status !== 'fulfilled') {
                    throw positionResult.reason;
                }

                const rows = positionResult.value;
                cachedPositions = Array.isArray(rows) ? rows : [];

                // renderPositions 会基于过滤后的持仓计算盈亏并返回
                const positionPnl = await renderPositions(cachedPositions);

                // 计算已实现盈亏并更新收益看板
                const realizedPnl = calculateRealizedPnl(trades);

                // 使用 renderPositions 返回的基于过滤后持仓的盈亏数据
                const currentPnl = positionPnl?.currentPnl ?? 0;
                const currentPnlPct = positionPnl?.currentPnlPct ?? 0;

                updatePnlDashboard({
                    currentPnl,
                    currentPnlPct,
                    last24hPnl: realizedPnl.last24h,
                    totalPnl: realizedPnl.total
                });

                st.textContent = `已加载 ${Array.isArray(rows) ? rows.length : 0} 条持仓`;
            } catch (err) {
                console.error(err);
                st.textContent = '加载失败（请检查网络/CORS 或稍后重试）';
            } finally {
                st.classList.remove('loading');
                tradeHint.classList.remove('loading');
                openOrderHint.classList.remove('loading');
            }
        }

        $('refresh').addEventListener('click', load);
        const positionRefreshBtn = $('positionRefresh');
        if (positionRefreshBtn) {
            positionRefreshBtn.addEventListener('click', () => refreshPositionsSection($('addr').value.trim()));
        }
        const hideSmallPositionsCheckbox = $('hideSmallPositions');
        if (hideSmallPositionsCheckbox) {
            hideSmallPositionsCheckbox.addEventListener('change', () => {
                // 如果有缓存的数据，直接重新渲染；否则尝试刷新
                if (cachedPositions.length > 0) {
                    rerenderCachedPositions();
                } else {
                    const addr = $('addr').value.trim();
                    if (addr && addr.startsWith('0x') && addr.length >= 10) {
                        refreshPositionsSection(addr);
                    }
                }
            });
        }
        const openOrderRefreshBtn = $('openOrderRefresh');
        if (openOrderRefreshBtn) {
            openOrderRefreshBtn.addEventListener('click', () => refreshOpenOrdersSection());
        }
        const tradeRefreshBtn = $('tradeRefresh');
        if (tradeRefreshBtn) {
            tradeRefreshBtn.addEventListener('click', () => refreshTradesSection($('addr').value.trim()));
        }
        window.handleCloseOrder = handleCloseOrder;

        // 初始化：加载当前地址
        (async () => {
            try {
                const address = await fetchCurrentAddress();
                if (address) {
                    $('addr').value = address;
                }
            } catch (err) {
                console.error('Failed to fetch current address:', err);
            }
            load();
        })();
    </script>
</body>

</html>
